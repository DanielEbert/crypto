<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: AESMath Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classAESMath-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AESMath Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="AESMath_8h_source.html">AESMath.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a09bba3b08a03d0bd2abf1d20473bc895"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#a09bba3b08a03d0bd2abf1d20473bc895">AESMath</a> ()</td></tr>
<tr class="separator:a09bba3b08a03d0bd2abf1d20473bc895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed763f8e7b98d7d9c2bbf927b92f4c10"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#aed763f8e7b98d7d9c2bbf927b92f4c10">exp</a> (byte i) const</td></tr>
<tr class="separator:aed763f8e7b98d7d9c2bbf927b92f4c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0439aae492e373f657dc157ecd7ca6"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#aff0439aae492e373f657dc157ecd7ca6">inv</a> (byte b) const</td></tr>
<tr class="separator:aff0439aae492e373f657dc157ecd7ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dc0d4d9c71f76c9ab161b322af3dc0"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#a81dc0d4d9c71f76c9ab161b322af3dc0">log</a> (byte i) const</td></tr>
<tr class="separator:a81dc0d4d9c71f76c9ab161b322af3dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:addc85b43cc512b64b72572a0d446c1ca"><td class="memItemLeft" align="right" valign="top">static byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#addc85b43cc512b64b72572a0d446c1ca">add</a> (byte a, byte b)</td></tr>
<tr class="separator:addc85b43cc512b64b72572a0d446c1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a287fd250ea67015652ea3fa292d900cd"><td class="memItemLeft" align="right" valign="top">vector&lt; byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#a287fd250ea67015652ea3fa292d900cd">log_table</a></td></tr>
<tr class="separator:a287fd250ea67015652ea3fa292d900cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6600fb4fd42edb4d6932cb376da0034"><td class="memItemLeft" align="right" valign="top">vector&lt; byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#af6600fb4fd42edb4d6932cb376da0034">exp_table</a></td></tr>
<tr class="separator:af6600fb4fd42edb4d6932cb376da0034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606f45e378a2e7c0198ab06b2167f544"><td class="memItemLeft" align="right" valign="top">vector&lt; byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#a606f45e378a2e7c0198ab06b2167f544">sbox</a></td></tr>
<tr class="separator:a606f45e378a2e7c0198ab06b2167f544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0c4a4ec8a16a825fb116dd3f741b6b"><td class="memItemLeft" align="right" valign="top">vector&lt; byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#a6d0c4a4ec8a16a825fb116dd3f741b6b">inv_sbox</a></td></tr>
<tr class="separator:a6d0c4a4ec8a16a825fb116dd3f741b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842cd3b0a60f9107120118cdfc3629b5"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#a842cd3b0a60f9107120118cdfc3629b5">mul</a> (byte a, byte b) const</td></tr>
<tr class="separator:a842cd3b0a60f9107120118cdfc3629b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce0a17ec84450d84559a814251061ae"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#a9ce0a17ec84450d84559a814251061ae">sBox</a> (byte b) const</td></tr>
<tr class="separator:a9ce0a17ec84450d84559a814251061ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f17ad9d2c0a001ba953ac7575f16d8a"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#a6f17ad9d2c0a001ba953ac7575f16d8a">invSBox</a> (byte b) const</td></tr>
<tr class="separator:a6f17ad9d2c0a001ba953ac7575f16d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68752913a10216b02ca7ee07d3cfce73"><td class="memItemLeft" align="right" valign="top">static byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#a68752913a10216b02ca7ee07d3cfce73">atrans</a> (byte x)</td></tr>
<tr class="separator:a68752913a10216b02ca7ee07d3cfce73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520e8de49844b680fce0d35b95f62ef7"><td class="memItemLeft" align="right" valign="top">static byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#a520e8de49844b680fce0d35b95f62ef7">rpmul</a> (byte a, byte b)</td></tr>
<tr class="separator:a520e8de49844b680fce0d35b95f62ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80138d32a161659fffc62d1feba18c0"><td class="memItemLeft" align="right" valign="top">static byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#ab80138d32a161659fffc62d1feba18c0">parity</a> (byte b)</td></tr>
<tr class="separator:ab80138d32a161659fffc62d1feba18c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f882d756de848b280e5bf36d8ae2651"><td class="memItemLeft" align="right" valign="top"><a id="a9f882d756de848b280e5bf36d8ae2651"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>printTable</b> (const vector&lt; byte &gt; &amp;table)</td></tr>
<tr class="separator:a9f882d756de848b280e5bf36d8ae2651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca9aef55b91f32f116a84280d5e6408"><td class="memItemLeft" align="right" valign="top">static byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESMath.html#a6ca9aef55b91f32f116a84280d5e6408">xtime</a> (byte b)</td></tr>
<tr class="separator:a6ca9aef55b91f32f116a84280d5e6408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e823fb436d9a77d8078f2b39a912a6d"><td class="memItemLeft" align="right" valign="top"><a id="a4e823fb436d9a77d8078f2b39a912a6d"></a>
static string&#160;</td><td class="memItemRight" valign="bottom"><b>format</b> (byte b)</td></tr>
<tr class="separator:a4e823fb436d9a77d8078f2b39a912a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Diese Klasse bietet Hilfsfunktionen für AES an.</p>
<p>Im AES Algorithmus basiert die Mathematik auf dem endlichen Körper GF(256). Diese Klasse implementiert Verfahren, um mit diesem Körper zu arbeiten. Elemente von endlichen Körpern können addiert und multipliziert werden. Allerdings unterscheiden sich diese Verfahren von denen für Zahlen. Die Elemente haben ebenfalls ein inverses Element.</p>
<p>Ein Körper ist eine algebraische Struktur mit (A, '⊕', '°'). (In den Folien ist das Symbole für die Division ° anders, aber das in der Folie verwendete Symbole kann nicht richtig abebildet werden. In dieser Dokumentation wird aus diesem Grund ° für die endlichen Körper Division verwendet.) Der Körper hat die Eigenschaft, dass (A, ⊕) und (A0}, °) kommutative Gruppen sind, dass das Distributivgesetz gilt und dass ||A|| &lt; ∞.</p>
<p>Die Elemente im Körper werden in einem Byte als 8-Tupel über {0,1} dargestellt. Sie werden als Polynome mit Grad 7 und Koeffizienten in {0,1} interpretiert. Das Element (h,g,f,e,d,c,b,a) ∈ {0,1}^8 steht für das Polynom hx^7 + gx^6 + fx^5 + ex^4 + dx^3 + cx^2 + xb + a. Dabei ist a das niedrigwertigste Bit des Bytes, b das zweit niedrigwertigste, ..., und h das höchstwertigste bit des Bytes, in dem das Polynom gespeichert ist. Das Byte mit Hexadezimalwert 57 (in binary 01010111) steht für das Polynom x^6 + x^4 + x^2 + x + 1. An die Funktionen dieser Klasse werden bytes übergeben. Diese bytes werden wie die hier beschriebenen Polynome interpretiert. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a09bba3b08a03d0bd2abf1d20473bc895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09bba3b08a03d0bd2abf1d20473bc895">&#9670;&nbsp;</a></span>AESMath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AESMath::AESMath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dieser Konstrukor setzt die Lookup-Tabellen exp_table, log_table, sbox und inv_sbox. Die möglichen Eingabewerte für exp, log, sbox und insbox sind jeweils 256 Elemente groß. Dadurch kann das Ergebnis für jede mögliche Eingabe an exp_table, log_table, sbox und inv_sbox bereits im Vorfeld berechnet werden.</p>
<p>Nachdem diese Lookup Tabellen einmal berechnet wurden, können sie weiter dazu verwendet werden, um Berechnungen in anderen Funktionen dieser Klasse schneller abzuarbeiten. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="addc85b43cc512b64b72572a0d446c1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc85b43cc512b64b72572a0d446c1ca">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte AESMath::add </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Polynomaddition auf dem endlichen Körper GF(256).</p>
<p>In der hier verwendeten Polynomialrepräsentation ist die Summe zweier Elemente in GF(256) das Polynom mit den Koeffizienten, die durch die Summe mod 2 der Koeffizienten der Elemente a und b gegeben sind. Dabei ist für jedes i = 0,1,..,7: i-te Bit in a + i-te Bit in b mod 2 ergibt das i-te Bit des Ergebnisses. Diese Rechnung kann als a XOR b implementiert werden.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Ein Byte in Polynomialrepräsentation. a ist einer der Summanden. </td></tr>
    <tr><td class="paramname">b</td><td>Ein Byte in Polynomialrepräsentation. b ist einer der Summanden. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Das Ergebnis der Polynomaddition von a ⊕ b als Byte in Polynomialrepräsentation. </dd></dl>

</div>
</div>
<a id="a68752913a10216b02ca7ee07d3cfce73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68752913a10216b02ca7ee07d3cfce73">&#9670;&nbsp;</a></span>atrans()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte AESMath::atrans </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>atrans implementiert eine affine Transformation über GF(2). Diese Transformation wird als Substitution in ByteSub von AES verwendet und ist umkehrbar. Eine vorgegebene 8x8 Matrix wird wird mit Hilfe der Matrixmultiplikation mit dem Übergabeparameter x multipliziert und anschließend mit einem weiteren 8 Elemente großen Vektor additiert. Wie erläutert werden diese Operationen über dem Körper GF(2) ausgeführt.</p>
<p>Diese Funktion wird bei der Berechnung der S-box im Konstruktor dieser Klasse verwendet. Die S-Box wird wiederum bei der ByteSub Transformation in AES verwendet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Eingabebyte, auf welches die affine Transformation angewendet wird. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ergebnis als Byte der affinen Transformation mit x </dd></dl>

</div>
</div>
<a id="aed763f8e7b98d7d9c2bbf927b92f4c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed763f8e7b98d7d9c2bbf927b92f4c10">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte AESMath::exp </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>exp berechnet 3^i (über GF(256)). 3 ist ein Generator von GF(256).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Exponent als Byte in Polynomialrepräsentation. </td></tr>
    <tr><td class="paramname">return</td><td>Das Ergebnis von 3^i, als Byte in Polynomialrepräsentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff0439aae492e373f657dc157ecd7ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0439aae492e373f657dc157ecd7ca6">&#9670;&nbsp;</a></span>inv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte AESMath::inv </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>inv berechnet das multiplikative Inverse von b. b ist ein Element in GF(256). Das Ergebnis ist ebenfalls ein Element in GF(256). Bei der Eingabe 0 wird 0 als Byte zurückgegeben.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Zu invertierendes Byte in Polynomialrepräsentation. </td></tr>
    <tr><td class="paramname">return</td><td>Das Inverse Element von b als Byte in Polynomialrepräsentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f17ad9d2c0a001ba953ac7575f16d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f17ad9d2c0a001ba953ac7575f16d8a">&#9670;&nbsp;</a></span>invSBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte AESMath::invSBox </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>invSBox um die Substitution der sBox rückgängig zu machen. Zum Beispiel: Angenommen sBox(1) = 10, dann ist invSBox(10) = 1. Dafür wird zuerst die affine Transformation atrans invertiert und danach das multiplikative Inverse in GF(256) des Ergebnisses der invertierten affinen Transformation berechnet und zurückgegeben. In dieser Implementation sind diese Werte bereits im inv_sbox Table gecached, wo sie über den sbox Table berechnet worden sind.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Eingabebyte, auf welches die zwei bijektive Abbildungen angewendet werden. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ergebnis als byte der zwei auf b angewendeten bijektive Abbildungen. </dd></dl>

</div>
</div>
<a id="a81dc0d4d9c71f76c9ab161b322af3dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81dc0d4d9c71f76c9ab161b322af3dc0">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte AESMath::log </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>log berechnet log3(i) (über GF(256)). 3 ist ein Generator von GF(256).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Zu berechnendes Byte in Polynomialrepräsentation. </td></tr>
    <tr><td class="paramname">return</td><td>Das Ergebnis von 3^i, als Byte in Polynomialrepräsentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a842cd3b0a60f9107120118cdfc3629b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842cd3b0a60f9107120118cdfc3629b5">&#9670;&nbsp;</a></span>mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte AESMath::mul </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Polynommultiplikation auf dem endlichen Körper GF(256).</p>
<p>Da in AES der endliche Körpert GF(256) fest gewählt ist, kann die Multiplikation effizient durch die im Konstruktur berechneten Lookup Tabellen implementiert werden. Da (GF(256)0}, °) eine zyklische Gruppe ist, besitzt sie ein erzeugendes Element g. In diesem Fall ist g = 3. Um a°b zu berechnen, verwendet man den Generator g. Falls a=g^i und b=g^j ist, dann ist a°b = g^i ° g^j = g^((i+j) mod 255).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Ein Byte in Polynomialrepräsentation. a ist der Multiplikator. </td></tr>
    <tr><td class="paramname">b</td><td>Ein Byte in Polynomialrepräsentation. b ist der Multiplikand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Das Ergebnis der Polynommultiplikation von a ° b als Byte in Polynomialrepräsentation. </dd></dl>

</div>
</div>
<a id="ab80138d32a161659fffc62d1feba18c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80138d32a161659fffc62d1feba18c0">&#9670;&nbsp;</a></span>parity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte AESMath::parity </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Die Parity-Funktion berechnet die Anzahl der Einsen in der Binärdarstellung eines Bytes und gibt an, ob diese gerade oder ungerade ist. Ist sie ungerade, dann wird 1 zurückgegeben. Andernfalls wird 0 zurückgegeben.</p>
<p>Diese Funktion wird als Hilfsfunktion in der Berechnung der linearen Transformation verwendet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Das Byte, welches nach einer geraden Anzahl von Einsen überprüft wird. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1, wenn die Anzahl der Eines in b ungerade ist. 0 wenn nicht. </dd></dl>

</div>
</div>
<a id="a520e8de49844b680fce0d35b95f62ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520e8de49844b680fce0d35b95f62ef7">&#9670;&nbsp;</a></span>rpmul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte AESMath::rpmul </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Russische Bauernmultiplikation über GF(256).</p>
<p>Die Russische Bauernmultiplikation berechnet das Produkt zweier ganzer Zahlen a und b über GF(256).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Ein Byte in Polynomialrepräsentation. a ist der Multiplikator. </td></tr>
    <tr><td class="paramname">b</td><td>Ein Byte in Polynomialrepräsentation. b ist der Multiplikand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Das Ergebnis der Polynommultiplikation von a ° b als Byte in Polynomialrepräsentation. </dd></dl>

</div>
</div>
<a id="a9ce0a17ec84450d84559a814251061ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce0a17ec84450d84559a814251061ae">&#9670;&nbsp;</a></span>sBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte AESMath::sBox </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sBox für die Substitution.</p>
<p>sBox wendet zwei bijektive Abbildungen auf b an und liefert das Ergebnis als byte zurück. Als erstes wird dabei b auf sein multiplikatives Inverses abgebildet. Zweitens wird das im ersten Schritt berechnete multiplikative Inverse von b mit einer in atrans berechneten affinen Abbildung über GF(2) abgebildet. In dieser Implemenation werden Lookup Tabellen verwendet, um dieses Prozess zu beschläunigen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Eingabebyte, auf welches die zwei bijektive Abbildungen angewendet werden. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ergebnis als byte der zwei auf b angewendeten bijektive Abbildungen. </dd></dl>

</div>
</div>
<a id="a6ca9aef55b91f32f116a84280d5e6408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca9aef55b91f32f116a84280d5e6408">&#9670;&nbsp;</a></span>xtime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte AESMath::xtime </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>xtime multipliziert ein Element aus GF(256) mit 2 (über GF(256)) und liefert das Ergebnis, welches ebenfalls ein Element aus GF(256) ist, als Byte in Polynomialrepräsentation zurück.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Das zu multiplizierende Element aus GF(256) als Byte in Polynomialrepräsentation. </td></tr>
    <tr><td class="paramname">return</td><td>2°b, ein Element aus GF(256) als Byte in Polynomialrepräsentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af6600fb4fd42edb4d6932cb376da0034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6600fb4fd42edb4d6932cb376da0034">&#9670;&nbsp;</a></span>exp_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;byte&gt; AESMath::exp_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lookup Tabelle für 3^i (über GF(256)). i ist der Index in die Tabelle. </p>

</div>
</div>
<a id="a6d0c4a4ec8a16a825fb116dd3f741b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0c4a4ec8a16a825fb116dd3f741b6b">&#9670;&nbsp;</a></span>inv_sbox</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;byte&gt; AESMath::inv_sbox</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lookup Tabelle für das invertieren der zwei bijektiven Abbildungen der SBox. Macht die Substitution der sbox wieder rückgängig. </p>

</div>
</div>
<a id="a287fd250ea67015652ea3fa292d900cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287fd250ea67015652ea3fa292d900cd">&#9670;&nbsp;</a></span>log_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;byte&gt; AESMath::log_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lookup Tabelle für log3(i) (über GF(256)). i ist der Index in die Tabelle. Macht die Exponentation <a class="el" href="classAESMath.html#aed763f8e7b98d7d9c2bbf927b92f4c10">exp()</a> mit exp_table wieder rückgängig. </p>

</div>
</div>
<a id="a606f45e378a2e7c0198ab06b2167f544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606f45e378a2e7c0198ab06b2167f544">&#9670;&nbsp;</a></span>sbox</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;byte&gt; AESMath::sbox</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lookup Tabelle für die zwei bijektiven Abbildungen der SBox. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/sinflair/P/crypto/AK/src/Praktikum-AES/<a class="el" href="AESMath_8h_source.html">AESMath.h</a></li>
<li>/home/sinflair/P/crypto/AK/src/Praktikum-AES/AESMath.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
