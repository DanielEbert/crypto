<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: AESState Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classAESState-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AESState Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="AESState_8h_source.html">AESState.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for AESState:</div>
<div class="dyncontent">
<div class="center"><img src="classAESState__coll__graph.png" border="0" usemap="#AESState_coll__map" alt="Collaboration graph"/></div>
<map name="AESState_coll__map" id="AESState_coll__map">
<area shape="rect" id="node2" href="classAESMath.html" title="AESMath" alt="" coords="6,5,85,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2cc9414a52e4f828dce31db66af44f12"><td class="memItemLeft" align="right" valign="top"><a id="a2cc9414a52e4f828dce31db66af44f12"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AESState</b> (const <a class="el" href="classAESMath.html">AESMath</a> &amp;aesmath, bool <a class="el" href="classAESState.html#a7cd68a8ad4ea900df93a9adca4531a04">debug_mode</a>=false)</td></tr>
<tr class="separator:a2cc9414a52e4f828dce31db66af44f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289634d47fcbde24b1464c8b82ee04f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESState.html#a289634d47fcbde24b1464c8b82ee04f5">set</a> (const byte *in)</td></tr>
<tr class="separator:a289634d47fcbde24b1464c8b82ee04f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374f83c433060db458a586923b2aa116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESState.html#a374f83c433060db458a586923b2aa116">get</a> (byte *out)</td></tr>
<tr class="separator:a374f83c433060db458a586923b2aa116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed74abc14779f7d8fcbfea6f06649640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESState.html#aed74abc14779f7d8fcbfea6f06649640">shiftRows</a> ()</td></tr>
<tr class="separator:aed74abc14779f7d8fcbfea6f06649640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18b4607210ae88bd825e7b9ca4529a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESState.html#ab18b4607210ae88bd825e7b9ca4529a6">subBytes</a> ()</td></tr>
<tr class="separator:ab18b4607210ae88bd825e7b9ca4529a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88494d311817ef8ac87984fdc475b138"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESState.html#a88494d311817ef8ac87984fdc475b138">mixColumns</a> ()</td></tr>
<tr class="separator:a88494d311817ef8ac87984fdc475b138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dcc6810da02059f3dea7ef0ad50a8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESState.html#a08dcc6810da02059f3dea7ef0ad50a8e">invShiftRows</a> ()</td></tr>
<tr class="separator:a08dcc6810da02059f3dea7ef0ad50a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa9f233a7776649ac044d581f88f240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESState.html#abfa9f233a7776649ac044d581f88f240">invSubBytes</a> ()</td></tr>
<tr class="separator:abfa9f233a7776649ac044d581f88f240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a16a03a1569836f8876d9822e8d3874"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESState.html#a5a16a03a1569836f8876d9822e8d3874">invMixColumns</a> ()</td></tr>
<tr class="separator:a5a16a03a1569836f8876d9822e8d3874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd8d914886e56653c5a78d3605abf1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESState.html#abdd8d914886e56653c5a78d3605abf1d">addKey</a> (const word *key)</td></tr>
<tr class="separator:abdd8d914886e56653c5a78d3605abf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968bcb473d9dfb281f9d753d621792c9"><td class="memItemLeft" align="right" valign="top"><a id="a968bcb473d9dfb281f9d753d621792c9"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>format</b> () const</td></tr>
<tr class="separator:a968bcb473d9dfb281f9d753d621792c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a40b1c825513553815de61e1f8e2b89be"><td class="memItemLeft" align="right" valign="top"><a id="a40b1c825513553815de61e1f8e2b89be"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><b>getCell</b> (size_t row, size_t col)</td></tr>
<tr class="separator:a40b1c825513553815de61e1f8e2b89be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc413a6fdf8211a8c81341c5fb98b2f"><td class="memItemLeft" align="right" valign="top"><a id="a8fc413a6fdf8211a8c81341c5fb98b2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setCell</b> (size_t row, size_t col, byte b)</td></tr>
<tr class="separator:a8fc413a6fdf8211a8c81341c5fb98b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b0ce9b90a20e90ebe714a96cb0513c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESState.html#ad0b0ce9b90a20e90ebe714a96cb0513c">shiftRow</a> (size_t row, size_t shift)</td></tr>
<tr class="separator:ad0b0ce9b90a20e90ebe714a96cb0513c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0ecd8ba384844aec6e8ad93b9ad1477b"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESState.html#a0ecd8ba384844aec6e8ad93b9ad1477b">state</a> [16]</td></tr>
<tr class="separator:a0ecd8ba384844aec6e8ad93b9ad1477b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7cd68a8ad4ea900df93a9adca4531a04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESState.html#a7cd68a8ad4ea900df93a9adca4531a04">debug_mode</a></td></tr>
<tr class="separator:a7cd68a8ad4ea900df93a9adca4531a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd42377ff30e9d15bfef8a09e768380e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAESMath.html">AESMath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAESState.html#afd42377ff30e9d15bfef8a09e768380e">math</a></td></tr>
<tr class="separator:afd42377ff30e9d15bfef8a09e768380e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classAESState.html">AESState</a> stellt den internen Zustand von AES dar. Der interne Zustand wird state genannt. Im Standard ist state ein Zweidimensionales Array. In dieser Implementierung wird dieser Zweidimensionales Array in einem eindimensionales Array gespeichert, wobei die Spalten hintereinander konkateniert abgespeichert werden. Wie in den anderen Klassen für AES dieser Implementierung wird davon ausgegangen, dass nb = 4 ist. Der state ist deshalb 16 Byte groß. Für das Ver- oder Entschlüsseln wird der state auf die Eingabe gesetzt. Nach einer Reihe von Transformationen enthält der State das Resultat der Ver- oder Entschlüsselung.</p>
<p>Weiter werden Funktionen angeboten, welche den State verändern/transformieren.</p>
<p>Wie in den anderen Klassen für AES dieser Implementierung wird davon ausgegangen, dass nb = 4 ist. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abdd8d914886e56653c5a78d3605abf1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd8d914886e56653c5a78d3605abf1d">&#9670;&nbsp;</a></span>addKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESState::addKey </td>
          <td>(</td>
          <td class="paramtype">const word *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>addKey implementiert die AddRoundKey Transformation, wobei der Rundenschlüssel in key auf den internen Zustand addiert wird. Bei dieser Addition wird jedes Byte des Zustand mit dem entsprechenden Byte des Rundenschlüssels mit XOR verknüpft. Der Rundenschlüssel muss dabei die Größe der state haben. Da diese in unserer Implementierung fest gesetzt ist, muss jeder Rundenschlüssel eine Größe von 16 Byte haben.</p>
<p>Jeder Rundenschlüssel besteht aus 16 Bytes der key_schedule.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Zeiger auf den key, welcher der Rundenschlüssel ist, der für die AddRoundKey Transformation verwendet wird. Dieser Rundenschlüssel muss eine Größe von 16 Byte, also 4 words haben. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a374f83c433060db458a586923b2aa116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374f83c433060db458a586923b2aa116">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESState::get </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setzt die 16 Bytes ab *out auf die 16 Bytes von state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Zeiger auf einen mindestens 16 Byte großen Speicherbereich, an welchen das 16 Byte große state Array kopiert wird. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a16a03a1569836f8876d9822e8d3874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a16a03a1569836f8876d9822e8d3874">&#9670;&nbsp;</a></span>invMixColumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESState::invMixColumns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>invMixColumns macht die mixColumns Transformation wieder rückgänig. Dabei wird der Zustand spaltenweise transformiert, wobei eine Spalte als Vektor interpretiert wird und mit einer vorbestimmten 4x4 Matrix in GF(256) multipliziert wird. Diese 4x4 Matrix ist so gesetzt, damit die mixColumns Transformation invertiert bzw. rückgängig gemacht wird.</p>
<p>Jede Basisoperation auf den state kann invertiert werden. Diese Eigenschaft wird hier benötigt, um einen verschlüsselten Text wieder zu entschlüsseln. Für das Entschlüsseln werden die Basisoperationen durch ihre inversen Paare ersetzt und in umgekehrter Reihenfolge auf den state, also des cipher_texts, angewandt. </p>

</div>
</div>
<a id="a08dcc6810da02059f3dea7ef0ad50a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dcc6810da02059f3dea7ef0ad50a8e">&#9670;&nbsp;</a></span>invShiftRows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESState::invShiftRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>invShiftRows macht die shiftRows Funktion wieder rückgänig. Dafür wird die Reihe 1 wird um 3 Byte, Reihe 2 um 2 und Reihe 3 um 1 Byte zyklisch nach links verschoben. Da das Shiften zyklisch ist, kann an dieser Stelle ein Linkssshift anstelle eines Rechtsshifts verwendet werden. Wird für eine State shiftRows und danach invShiftRows aufgerufen, dann ist die daraus resultierende State die Gleiche wie vor dem Aufruf von <a class="el" href="classAESState.html#aed74abc14779f7d8fcbfea6f06649640">shiftRows()</a>.</p>
<p>Jede Basisoperation auf den state kann invertiert werden. Diese Eigenschaft wird hier benötigt, um einen verschlüsselten Text wieder entschlüsseln zu können. Für das Entschlüsseln werden die Basisoperationen durch ihre inversen Paare ersetzt und in umgekehrter Reihenfolge auf den state, also des cipher_texts, angewandt. </p>

</div>
</div>
<a id="abfa9f233a7776649ac044d581f88f240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa9f233a7776649ac044d581f88f240">&#9670;&nbsp;</a></span>invSubBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESState::invSubBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>invSubBytes macht die subBytes Substitution wieder rückgängig.</p>
<p>Jede Basisoperation auf den state kann invertiert werden. Diese Eigenschaft wird hier benötigt, um einen verschlüsselten Text wieder zu entschlüsseln. Für das Entschlüsseln werden die Basisoperationen durch ihre inversen Paare ersetzt und in umgekehrter Reihenfolge auf den state, also des cipher_texts, angewandt. </p>

</div>
</div>
<a id="a88494d311817ef8ac87984fdc475b138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88494d311817ef8ac87984fdc475b138">&#9670;&nbsp;</a></span>mixColumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESState::mixColumns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Führt die Basisoperation MixColumns auf den internen Zustand aus. Dabei wird der Zustand spaltenweise transformiert, wobei eine Spalte als Vektor interpretiert wird und mit einer vorbestimmten 4x4 Matrix in GF(256) multipliziert wird. </p>

</div>
</div>
<a id="a289634d47fcbde24b1464c8b82ee04f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289634d47fcbde24b1464c8b82ee04f5">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESState::set </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setzt die 16 Byte in state auf die 16 Bytes ab *in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Zeiger auf einen mindestens 16 Byte großen Speicherbereich. Diese 16 Bytes werden nach state kopiert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0b0ce9b90a20e90ebe714a96cb0513c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b0ce9b90a20e90ebe714a96cb0513c">&#9670;&nbsp;</a></span>shiftRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AESState::shiftRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>shiftRow führt eine zyklische Linksverschiebung der Zeile row der state um shift Positionen durch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Zeile der State, die verschoben werden soll. </td></tr>
    <tr><td class="paramname">shift</td><td>Anzahl der Positionen, um die die row nach links zyklisch verschoben werden wird. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed74abc14779f7d8fcbfea6f06649640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed74abc14779f7d8fcbfea6f06649640">&#9670;&nbsp;</a></span>shiftRows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESState::shiftRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Führt die Basisoperation ShiftRows auf den internen Zustand aus. ShiftRows shiftet die Reihen der state zyklisch um verschiedene offsets nach links. Reihe 0 wird nicht verschoben. Reihe 1 wird um 1 Byte, Reihe 2 um 2 und Reihe 3 um 3 Byte nach links zyklisch verschiebt. Diese Offsets können bei anderen Werten für nb auch unterschiedlich sein. </p>

</div>
</div>
<a id="ab18b4607210ae88bd825e7b9ca4529a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18b4607210ae88bd825e7b9ca4529a6">&#9670;&nbsp;</a></span>subBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESState::subBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Führt die Basisoperation SubBytes auf den internen Zustand aus. SubBytes transformiert den Zustand mit Hilfe einer Substritution mit der SBox, wobei jedes Byte des state über die sBox Funktion einen neuen Wert zugewiesen bekommt. sBox wendet zwei bijektive Abbildungen auf jedes Byte b in state an. Als erstes wird dabei b auf sein multiplikatives Inverses in GF(256) abgebildet. Zweitens wird das im ersten Schritt berechnete multiplikative Inverse von b mit einer affinen Abbildung abgebildet. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7cd68a8ad4ea900df93a9adca4531a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd68a8ad4ea900df93a9adca4531a04">&#9670;&nbsp;</a></span>debug_mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AESState::debug_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag zum Aktivieren von Debug-Ausgaben. Wenn True, dann werden Debug Ausgaben über stdout ausgegeben. </p>

</div>
</div>
<a id="afd42377ff30e9d15bfef8a09e768380e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd42377ff30e9d15bfef8a09e768380e">&#9670;&nbsp;</a></span>math</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAESMath.html">AESMath</a>* AESState::math</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Zeiger auf ein Objekt der Klasse <a class="el" href="classAESMath.html">AESMath</a>, welche Mathematische Operationen auf dem endlichen Körper GF(256) implementiert. </p>

</div>
</div>
<a id="a0ecd8ba384844aec6e8ad93b9ad1477b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecd8ba384844aec6e8ad93b9ad1477b">&#9670;&nbsp;</a></span>state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte AESState::state[16]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interner Zustand (Array mit 16 Byte) des AES</p>
<p>Die state kann als rechteckiges array von bytes interpretiert werden. Dieses Array hat 4 Reihen und weil nb auf 4 gesetzt ist auch 4 Zeilen (also eine Matrix mit Dimension 4x4). Gespeichert ist es allerdings in einem 1 dimensionalen Array, wobei die Spalten hintereinander konkateniert abgespeichert werden.</p>
<p>Auf diesen 16 Bytes werden die in dieser Klasse implementiereten Transformationen angewandt, um eine 16 Byte große Eingabe in state zu ver- oder entschlüsseln. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/sinflair/P/crypto/AK/src/Praktikum-AES/<a class="el" href="AESState_8h_source.html">AESState.h</a></li>
<li>/home/sinflair/P/crypto/AK/src/Praktikum-AES/AESState.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
