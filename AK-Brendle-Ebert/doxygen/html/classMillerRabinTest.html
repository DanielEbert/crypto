<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: MillerRabinTest Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classMillerRabinTest-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MillerRabinTest Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="MillerRabinTest_8h_source.html">MillerRabinTest.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a22be947d4a770cb10b2172f20145a69f"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMillerRabinTest.html#a22be947d4a770cb10b2172f20145a69f">boundedExponentation</a> (const Integer &amp;b, const Integer &amp;e, const Integer &amp;bound) const</td></tr>
<tr class="separator:a22be947d4a770cb10b2172f20145a69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0816ce3bbb435b36ac787771c41df4b5"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMillerRabinTest.html#a0816ce3bbb435b36ac787771c41df4b5">modularExponentation</a> (const Integer &amp;a, const Integer &amp;b, const Integer &amp;n) const</td></tr>
<tr class="separator:a0816ce3bbb435b36ac787771c41df4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96d13d89f0b6050a78d7cf1b1bbafae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMillerRabinTest.html#ad96d13d89f0b6050a78d7cf1b1bbafae">witness</a> (const Integer &amp;a, const Integer &amp;n) const</td></tr>
<tr class="separator:ad96d13d89f0b6050a78d7cf1b1bbafae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab042b5d5094f76eebf5b3ffdf5f3e0dc"><td class="memItemLeft" align="right" valign="top"><a id="ab042b5d5094f76eebf5b3ffdf5f3e0dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>witness2</b> (const Integer &amp;a, const Integer &amp;n) const</td></tr>
<tr class="separator:ab042b5d5094f76eebf5b3ffdf5f3e0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91724157cb0fc9286d9061859af0093c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMillerRabinTest.html#a91724157cb0fc9286d9061859af0093c">isPerfectPower</a> (const Integer &amp;n, Integer &amp;b, Integer &amp;e) const</td></tr>
<tr class="separator:a91724157cb0fc9286d9061859af0093c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4195df727ebfbe30d0f54d89b962253"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMillerRabinTest.html#ad4195df727ebfbe30d0f54d89b962253">searchBase</a> (const Integer &amp;n, const Integer &amp;e) const</td></tr>
<tr class="separator:ad4195df727ebfbe30d0f54d89b962253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46f9beca9d9cf358143efdcaf4ce81b"><td class="memItemLeft" align="right" valign="top"><a id="ab46f9beca9d9cf358143efdcaf4ce81b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>extendedEuklid</b> (const Integer &amp;a, const Integer &amp;b, Integer &amp;d, Integer &amp;x, Integer &amp;y) const</td></tr>
<tr class="separator:ab46f9beca9d9cf358143efdcaf4ce81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ec4eb195d5d597ea4dbca4e9c71be2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMillerRabinTest.html#ad8ec4eb195d5d597ea4dbca4e9c71be2">isPrime</a> (PRNG *rng, const Integer &amp;n, unsigned int s) const</td></tr>
<tr class="separator:ad8ec4eb195d5d597ea4dbca4e9c71be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Diese Klasse implementiert den Miller-Rabin Primzahltest, einen Monte-Carlo Algorithmus, der mit einer bestimmten Fehlerwahrscheinlichkeit entscheiden kann, ob eine Zahl eine Primzahl ist. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a22be947d4a770cb10b2172f20145a69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22be947d4a770cb10b2172f20145a69f">&#9670;&nbsp;</a></span>boundedExponentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Integer MillerRabinTest::boundedExponentation </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Die Methode <a class="el" href="classMillerRabinTest.html#a22be947d4a770cb10b2172f20145a69f">boundedExponentation()</a> berechnet die Ganzzahlpotenz b^e und arbeitet dafür auf einer abgewandelten Form des Alogrithmus für Modulare Exponentiation. Während der Berechnung der Ganzzahlpotenz prüft der Algorithmus, ob dass Zwischenergebnis größer als die angegebene Obergrenze bound ist. Ist dies der Fall, bricht die Berechnung ab und bound+1 wird zurückgegeben. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Basis der zu berechnenden Ganzzahlpotenz </td></tr>
    <tr><td class="paramname">e</td><td>Exponent der zu berechnenden Ganzzahlpotenz </td></tr>
    <tr><td class="paramname">bound</td><td>Obergrenze für die die zu berechnende Ganzzahlpotenz </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bound+1, wenn die Ganzzahlpotenz größer als bound ist, b^e, wenn die Ganzzahlpotenz kleiner oder gleich bound ist </dd></dl>

</div>
</div>
<a id="a91724157cb0fc9286d9061859af0093c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91724157cb0fc9286d9061859af0093c">&#9670;&nbsp;</a></span>isPerfectPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MillerRabinTest::isPerfectPower </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Die Methode isPerfectPower kann zur Lösung des Entscheidungsproblems Ganzzahlpotenz verwendet werden. In diesem Entscheidungsproblem ist für eine natürliche Zahl n &gt; 2 gefragt, ob es sich dabei um eine Ganzzahlpotenz handelt. Der Algorithmus überprüft für alle möglichen Exponenten e, ob ein b existiert, sodass b^e = n. Dafür wird für jedes mögliche e zwischen 2 und log₂(n)+1 die Methode <a class="el" href="classMillerRabinTest.html#ad4195df727ebfbe30d0f54d89b962253">searchBase()</a> aufgerufen und anschließend überprüft, ob dieser eine Basis gefunden hat, sodass b^e = n. Falls eine Basis gefunden wurde, werden diese in den Parametern b und e gespeichert. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Zahl, für die festgestellt werden soll, ob es sich um eine Ganzzahlpotenz handelt oder nicht </td></tr>
    <tr><td class="paramname">b</td><td>Im Parameter b wird die Basis der Ganzzahlpotenz gespeichert, wenn es sich bei n um eine Ganzzahlpotenz handelt </td></tr>
    <tr><td class="paramname">e</td><td>Im Parameter e wird der Exponent der Ganzzahlpotenz gespeichert, wenn es sich bei n um eine Ganzzahlpotenz handelt </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, wenn es sich bei n um eine Ganzzahlpotenz handelt. In diesem Fall wird die Basis und der Exponent dieser Ganzzahlpotenz in den Parametern b und e gespeichert. Wenn es sich um keine Ganzzahlpotenz handelt, dann gibt die Methode False zurück. </dd></dl>

</div>
</div>
<a id="ad8ec4eb195d5d597ea4dbca4e9c71be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ec4eb195d5d597ea4dbca4e9c71be2">&#9670;&nbsp;</a></span>isPrime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MillerRabinTest::isPrime </td>
          <td>(</td>
          <td class="paramtype">PRNG *&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Die Methode <a class="el" href="classMillerRabinTest.html#ad8ec4eb195d5d597ea4dbca4e9c71be2">isPrime()</a> implementiert den Miller-Rabin Primzahltest. Dieser Algorithmus ist ein Monte Carlo Algorithmus. Ein Monte Carlo Algorithmus ist ein Algorithmus, der folgende Eigenschaften besitzt: Der Algorithmus bekommt als Eingabe eine beliebig lange Bitfolge und gibt als Ergebnis 0 oder 1 zurück; der Algorithmus hat Zugriff auf einen Zufallsgenerator, der Zufallsbits zurückliefert, die gleichverteilt sind; der Algorithmus berechnet das korrekte Ergebnis, mit der Wahrscheinlichkeit von (1/2) + Ɛ, wobei Ɛ &gt; 0. Der Miller-Rabin Primzahltest besitzt einen einseitigen Fehler. Wird eine Zahl von ihm als eine zusammengesetzte Zahl eingestuft, dann ist das Ergebnis zu 100 Prozent korrekt. Wird eine Zahl jedoch als Primzahl erkannt, dann ist das Ergebnis mit einer Wahrscheinlichkeit von 1-2^(-s) korrekt. Diese Fehlerwahrscheinlichkeit wird durch den Qualitätsparameter s beeiflusst, der angibt, wie viele zufällige Zahlen zwischen 1 und n-1 erzeugt werden und daraufhin überprüft werden, ob sie ein Solider Beweis sind, dass n eine zusammengesetzte Zahl ist.Die Laufzeit des Miller-Rabin Primzahltests beträgt O(log₂(n)³ * s). Eine Vorraussetzung für den Einsatz des Miller-Rabin Primzahltests sind kryptographisch gute Zufallszahlen. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>Zufallsgenerator mit dem die benötigten Zufallszahlen erzeugt werden </td></tr>
    <tr><td class="paramname">n</td><td>Integer, für den untersucht werden soll, ob es sich um eine Primzahl oder um eine zusammengesetze Zahl handelt </td></tr>
    <tr><td class="paramname">s</td><td>Qualitätsparameter s, der angibt, wie oft die Schleife durchlaufen werden soll </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, wenn die Zahl eine Primzahl ist, False wenn die Zahl eine zusammengesetze Zahl ist </dd></dl>

</div>
</div>
<a id="a0816ce3bbb435b36ac787771c41df4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0816ce3bbb435b36ac787771c41df4b5">&#9670;&nbsp;</a></span>modularExponentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Integer MillerRabinTest::modularExponentation </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Diese Methode implementiert den Algorithmus Modulare Exponentiation. Mit diesem Verfahren kann der Term a^b mod n effizient berechnet werden. Dafür wird b in seine Binärdarstellung zerlegt und das Ergebnis der Potenz durch Multiplikation und Quadratur berechnet. Eine Variable d startet mit Wert 1 und wird für jedes Bit von b quadriert. Falls das Bit gleich 1 ist, dann wird d noch zusätzlich mit dem Wert von a multipliziert. Alle diese Berechnungen finden modulo n statt, damit die Zwischenergebnisse nicht zu groß werden und der Alogrithmus das Ergebnis in effizienter Zeit berechnen kann. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Basis der Exponentiation vom Crypto++ Typ Integer </td></tr>
    <tr><td class="paramname">b</td><td>Exponent der Exponentiation vom Crypto++ Typ Integer </td></tr>
    <tr><td class="paramname">n</td><td>Modulus der Exponentiation vom Crypto++ Typ Integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ergebnis der Berechnung a^b (mod n) </dd></dl>

</div>
</div>
<a id="ad4195df727ebfbe30d0f54d89b962253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4195df727ebfbe30d0f54d89b962253">&#9670;&nbsp;</a></span>searchBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Integer MillerRabinTest::searchBase </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dieser Algorithmus berechnet für natürliche Zahlen n &gt;= 2 und e (mit e: 2 &lt;= e &lt;= log₂(n)+1), ob eine Basis b existiert, damit b^e = n. Dafür setzt der Algorithmus eine Binäre Suche ein, um b schneller zu finden bzw. effizienter festzustellen, dass kein solcher Wert b existiert. Der Algorithmus berechnet für den aktuell zu überprüfenden Wert b b^e mit dem Algorithmus für Bounded Exponentation (implementiert in Methode <a class="el" href="classMillerRabinTest.html#a22be947d4a770cb10b2172f20145a69f">boundedExponentation()</a>), welcher nicht mehr weiterrechnet, wenn ein Zwischenergebnis der Berechnung b^e größer als n ist. Ist das Ergebnis der Berechnung b^e = n, dann wird b zurückgegeben. Die Laufzeit des Algorithmus ist polynomial in der Größe der Binärdarstellung von n </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Zahl, für welche festgestellt werden soll, ob es sich dabei um eine Ganzzahlpotenz handelt </td></tr>
    <tr><td class="paramname">e</td><td>Exponent der Ganzzahlpotenz </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>b, falls ein b exisitiert, sodass b^e = n, ansonsten 0 </dd></dl>

</div>
</div>
<a id="ad96d13d89f0b6050a78d7cf1b1bbafae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96d13d89f0b6050a78d7cf1b1bbafae">&#9670;&nbsp;</a></span>witness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MillerRabinTest::witness </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Der Algorithmus witness ist eine abgewandelte Form der modularen Exponentiation, die für die übergebenen Parameter a und n den Term a^(n-1) (mod n) berechnet. Diese Berechnung soll den Satz von Fermat überprüfen. Der Satz von Fermat sagt aus: Ist n eine Primzahl, dann gilt für alle a in Z Stern n, dass: a^(n-1) kongruent zu 1 (mod n). Wenn das Ergebnis dieser Berechnung ungleich 1 ist, dann ist die Zahl definitiv keine Primzahl und a kann als Solider Beweis dafür angesehen werden, dass n keine Primzahl ist. Ein solider Beweis ist eine Zahl a in Z Stern n, die beweist, dass n eine zusammengesetzte Zahl ist. Sei n also eine beliebige ungerade natürliche Zahl, die größer 1 ist. Dann werden r und u so gewählt, dass n-1 = 2^r * u ist. Dann ist a eine solider Beweis, falls: 1. a^u nicht kongruent zu +1 oder -1 (modulo n) und 2. Für alle i=1 bis r-1 gilt: a ^(2^i * u) ist nicht kongruent zu -1 (modulo n). Wenn n eine beliebige, zusammengesetzte Zahl ist, die keine Primzahlpotenz ist, dann sind mindestens die Hälfte aller Zahlen in Z Stern n solide Beweise dafür, dass n eine zusammengesetzte Zahl ist. Ist das Ergebnis der Berechung des Fermat-Kriteriums a^(n-1) (mod n) jedoch gleich 1, dann ist es möglich, dass die Zahl eine Primzahl ist. Es existieren jedoch auch Carmichael Zahlen. Für diese seltenen, zusammengesetzten Zahlen gilt: Sei c eine Charmichael Zahl, dann gilt für alle a in Z Stern c, dass a^(n-1) kongruent zu 1 (modulo n). Deshalb reicht der Satz von Fermat allein nicht aus, um eine Primzahl zu erkennen. Deshalb wird während der Berechnung von a^(n-1) parallel dabei nach einer Lösung für die Gleichung x^2 kongruent zu 1 (mod n) gesucht, die verschieden zu 1 und -1 (also n-1) ist. Wird eine solche Zahl gefunden, dann ist a ein Solider Beweis dafür, dass n keine Primzahl ist. Diese Schlussfolgerung ist möglich, da wenn n eine Primzahl ungleich 2 ist, dann sind 1 und -1 die einzigen Quadratwurzeln von 1 (mod n) in Z Stern n. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Zahl in Z Stern n, für die überprüft wird, ob sie ein soldier Beweis dafür ist, dass n eine zusammengesetzte Zahl ist </td></tr>
    <tr><td class="paramname">n</td><td>Zahl, für die getestet werden soll, ob sie eine Primzahl ist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, wenn n keine Primzahl ist (a also ein Solider Beweis ist), ansonsten False </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/sinflair/P/crypto/AK/src/Praktikum-Primzahlen/<a class="el" href="MillerRabinTest_8h_source.html">MillerRabinTest.h</a></li>
<li>/home/sinflair/P/crypto/AK/src/Praktikum-Primzahlen/MillerRabinTest.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
