<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: PublicKeyAlgorithmBox Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classPublicKeyAlgorithmBox-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PublicKeyAlgorithmBox Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="PublicKeyAlgorithmBox_8h_source.html">PublicKeyAlgorithmBox.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af432af239a513852e29e044f6e498f01"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPublicKeyAlgorithmBox.html#af432af239a513852e29e044f6e498f01">computeConvergents</a> (const Integer &amp;a, const Integer &amp;b, vector&lt; Integer &gt; &amp;c, vector&lt; Integer &gt; &amp;d)</td></tr>
<tr class="separator:af432af239a513852e29e044f6e498f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cd13dd1778069cf633732c5c029d6a"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPublicKeyAlgorithmBox.html#af6cd13dd1778069cf633732c5c029d6a">euklid</a> (const Integer &amp;a, const Integer &amp;b, vector&lt; Integer &gt; &amp;q)</td></tr>
<tr class="separator:af6cd13dd1778069cf633732c5c029d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7239bae1cc6290e33c872c48ea52a0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPublicKeyAlgorithmBox.html#ac7239bae1cc6290e33c872c48ea52a0a">EEA</a> (const Integer &amp;a, const Integer &amp;b, Integer &amp;d, Integer &amp;x, Integer &amp;y)</td></tr>
<tr class="separator:ac7239bae1cc6290e33c872c48ea52a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422b73bfe57f6441757fc696410c3717"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPublicKeyAlgorithmBox.html#a422b73bfe57f6441757fc696410c3717">modularExponentation</a> (const Integer &amp;a, const Integer &amp;b, const Integer &amp;n)</td></tr>
<tr class="separator:a422b73bfe57f6441757fc696410c3717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64680677e539d24b59e8873ec4fe3bb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPublicKeyAlgorithmBox.html#a64680677e539d24b59e8873ec4fe3bb9">multInverse</a> (const Integer &amp;a, const Integer &amp;n, Integer &amp;a_inv)</td></tr>
<tr class="separator:a64680677e539d24b59e8873ec4fe3bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cf3ae489af192f0378fe418555f577"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPublicKeyAlgorithmBox.html#a04cf3ae489af192f0378fe418555f577">witness</a> (const Integer &amp;a, const Integer &amp;n)</td></tr>
<tr class="separator:a04cf3ae489af192f0378fe418555f577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfad37e2a5370f0c001edf2d694e30d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPublicKeyAlgorithmBox.html#a7dfad37e2a5370f0c001edf2d694e30d">millerRabinTest</a> (Integer &amp;n, unsigned int s)</td></tr>
<tr class="separator:a7dfad37e2a5370f0c001edf2d694e30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598a7a28b29517a85daeb50b560a895d"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPublicKeyAlgorithmBox.html#a598a7a28b29517a85daeb50b560a895d">randomInteger</a> (const Integer &amp;n)</td></tr>
<tr class="separator:a598a7a28b29517a85daeb50b560a895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1860632778c07e3990406413cda154f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPublicKeyAlgorithmBox.html#ae1860632778c07e3990406413cda154f">randomPrime</a> (Integer &amp;p, unsigned int bitlen, unsigned int s)</td></tr>
<tr class="separator:ae1860632778c07e3990406413cda154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea85d2370877359f5cfaf977d1e8c94e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPublicKeyAlgorithmBox.html#aea85d2370877359f5cfaf977d1e8c94e">randomRabinPrime</a> (Integer &amp;p, unsigned int bitlen, unsigned int s)</td></tr>
<tr class="separator:aea85d2370877359f5cfaf977d1e8c94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe8500da6a45e66caf4ffca7726cb16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPublicKeyAlgorithmBox.html#a9fe8500da6a45e66caf4ffca7726cb16">modPrimeSqrt</a> (const Integer &amp;y, const Integer &amp;p, vector&lt; Integer &gt; &amp;v)</td></tr>
<tr class="separator:a9fe8500da6a45e66caf4ffca7726cb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ae652ebf981342dc04fedf80b0a5bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPublicKeyAlgorithmBox.html#a44ae652ebf981342dc04fedf80b0a5bc">sqrt</a> (const Integer &amp;x, Integer &amp;s) const</td></tr>
<tr class="separator:a44ae652ebf981342dc04fedf80b0a5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64aff3d687c6cc1effca69b674b23fb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPublicKeyAlgorithmBox.html#a64aff3d687c6cc1effca69b674b23fb2">generateRSAParams</a> (Integer &amp;p, Integer &amp;q, Integer &amp;e, Integer &amp;d, unsigned int bitlen=256, unsigned int s=30)</td></tr>
<tr class="separator:a64aff3d687c6cc1effca69b674b23fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Die Klasse <a class="el" href="classPublicKeyAlgorithmBox.html">PublicKeyAlgorithmBox</a> stellt diverse zahlentheoretische Algorithmen bereit. Die Methoden dieser Klasse werden von anderen Klassen des Praktikum-Public-Key als Hilfsfunktionen verwendet. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af432af239a513852e29e044f6e498f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af432af239a513852e29e044f6e498f01">&#9670;&nbsp;</a></span>computeConvergents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int PublicKeyAlgorithmBox::computeConvergents </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In der Methode computeConvergents werden die Konvergenten des Kettenbruchs von a/b berechnet. Die Konvergenten eines Kettenbruchs können auch als Näherungsbruch bezeichnet werden. Sei [q1,...,qm] ein Kettenbruch. Für alle j mit 1 &lt;= j &lt;= m gilt, dass der Kettenbruch Cj = [q1,...,qj] die j-te Konvergente des ursprünglichen Kettenbruch ist. Cj kann durch den Bruch c[j]/d[j] dargestellt werden. Dabei besitzt der Zähler c[j] die Werte: 1, wenn j = 0, q1, falls j= 1 und qj *c[j-1] +c[j-2], für alle j &gt;= 2. Der Nenner d[j] besitzt hingegen die Werte: 0, wenn j = 0, 1, falls j = 1 und qj * d[j-1] + d[j-2] für alle j &gt;= 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Integer Variable, die den Nenner des Bruchs enthält </td></tr>
    <tr><td class="paramname">b</td><td>Integer Variable, die den Zähler des Bruchs enthält </td></tr>
    <tr><td class="paramname">c</td><td>Vector, in dem die von der Methode berechneten c[j] für 0 &lt;= j &lt;= m gespeichert werden, welche jeweils den Zähler des j-ten Näherungsbruch repräsentieren. </td></tr>
    <tr><td class="paramname">d</td><td>Vector, in dem die von der Methode berecheten d[j] für 0 &lt;= j &lt;= m gespeichert werden, welche jeweils den Nenner des j-ten Näherungsbruch repräsentieren.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Die Länge des errechneten Vectors c </dd></dl>

</div>
</div>
<a id="ac7239bae1cc6290e33c872c48ea52a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7239bae1cc6290e33c872c48ea52a0a">&#9670;&nbsp;</a></span>EEA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PublicKeyAlgorithmBox::EEA </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EEA realisiert den Erweiterten Algorithmus von Euklid. Dabei wird der größte gemeinsame Teiler von a und b berechnet und in d gespeichert. Zusätzlich gilt, dass der größte gemeinsame Teiler von a und b das kleinste positive Element der Menge {ax + by | x, y ∈ Z} aller Linearkombinationen von a und b ist. Mit dem EEA wird zusätzlich dieses x und y berechnet und in (param) x und (param) y abgespeichert. Die Methode liefert True zurück, wenn a und b teilerfremd sind, also wenn gcd(a, b) gleich 1 ist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Eine ganze Zahl &gt; 0 als Integer </td></tr>
    <tr><td class="paramname">b</td><td>Eine ganze Zahl &gt; 0 als Integer </td></tr>
    <tr><td class="paramname">d</td><td>Diese Methode setzt d auf den größten gemeinsamen Teiler von a und b. </td></tr>
    <tr><td class="paramname">x</td><td>Diese Methode setzt x auf das x der oben erläuterten Linearkombination von {ax + by | x, y ∈ Z}. </td></tr>
    <tr><td class="paramname">y</td><td>Diese Methode setzt y auf das y der oben erläuterten Linearkombination von {ax + by | x, y ∈ Z}. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, wenn d = 1, also wenn gcd(a,b)=1 (und die beiden Integer teilerfremd sind), sonst False. </dd></dl>

</div>
</div>
<a id="af6cd13dd1778069cf633732c5c029d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cd13dd1778069cf633732c5c029d6a">&#9670;&nbsp;</a></span>euklid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Integer PublicKeyAlgorithmBox::euklid </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Die Methode euklid berechnet den endlichen Kettenbruch a/b mit Hilfe des euklidschen Algorithmus. Ein endlicher Kettenbruch ist ein Term, der durch q1 + (1/(q2 + (1/(q3 + ... + (1(qm))))) dargestellt werden kann, wobei q1 bis qm nicht-negative ganze Zahlen sind. Ein endlicher Kettenbruch kann auch als [q1,...,qm] dargestellt werden. Für alle Brüche a/b, mit a,b ∈ natürliche Zahlen, mit b &gt; 0, gilt, dass sie als endlicher Kettenbruch [q1,...,qm] dargestellt werden können. Dieser Kettenbruch kann mit Hilfe des Algorithmus von Euklid berechnet werden. Dabei repräsentiert jede errechnete Gleichung den Term r{m-1} = q{m}*r{m} + r{m+1}. In dieser Implementierung starten die Indexe der Zahlen eines Kettenbruchs mit 0, da diese innerhalb eines Vectors gespeichert werden. Die Berechnung des endlichen Kettenbruchs wird benötigt, um die Wiener-Attacke auf RSA durchzuführen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Integer Variable, die den Zähler des Bruchs enthält </td></tr>
    <tr><td class="paramname">b</td><td>Integer Variable (b &gt; 0), die den Nenner des Bruchs enthält </td></tr>
    <tr><td class="paramname">q</td><td>Vector in dem die Integer-Werte des Kettenbruchs [q1,...,qm] abgespeichert werden </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Berechneter gcd(a,b), welches das letzte Element des Kettenbruchs ist </dd></dl>

</div>
</div>
<a id="a64aff3d687c6cc1effca69b674b23fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64aff3d687c6cc1effca69b674b23fb2">&#9670;&nbsp;</a></span>generateRSAParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PublicKeyAlgorithmBox::generateRSAParams </td>
          <td>(</td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bitlen</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>s</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>generateRSAParams generiert Werte für einen RSA-Schlüssel. Speziell besteht der RSA Schlüssel K aus n, p, q, e, d. n ist das Produkt aus den Primzahlen p * q und kann somit ebenfalls aus den Werten p und q berechnet werden. n und e bilden den öffentlichen Schlüssel, p, q und d den privaten Teil des Schlüssels. Es wird ebenfalls sichergestellt, dass p != q, da sonst n einfach durch die Wurzel faktorisierbar ist. Für die Sicherheit von n darf n nicht einfach faktorisierbar sein.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>p ist eine bitlen-Bit Zufallszahl, die mit einer Wahrscheinlichkeit von 1-2^-s eine Primzahl ist. p wird von dieser Methode gesetzt. </td></tr>
    <tr><td class="paramname">q</td><td>q ist eine bitlen-Bit Zufallszahl, die mit einer Wahrscheinlichkeit von 1-2^-s eine Primzahl ist. q wird von dieser Methode gesetzt. </td></tr>
    <tr><td class="paramname">e</td><td>e ist eine Zufallszahl mit der Eigenschaft, dass der größte gemeinsame Teiler von e und ϕ(n) = 1 ist. e wird von dieser Methode gesetzt. </td></tr>
    <tr><td class="paramname">d</td><td>d ist das multiplikative Inverse von e mod ϕ(n) d wird von dieser Methode gesetzt. </td></tr>
    <tr><td class="paramname">bitlen</td><td>bitlen gibt die maximale Größe der zu generierenden Zufallszahlen p und q in Binärdarstellung an. bitlen kann vom Caller gesetzt werden und ist standardmäßig auf 256 gesetzt. </td></tr>
    <tr><td class="paramname">s</td><td>s ist das s in 2^-s, welches die Fehlerwahrscheinlichkeit dafür angibt, dass die generierte Zahl p keine Primzahl ist. Das selbe ist für q der Fall. s kann vom Caller gesetzt werden und ist standardmäßig auf 30 gesetzt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dfad37e2a5370f0c001edf2d694e30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfad37e2a5370f0c001edf2d694e30d">&#9670;&nbsp;</a></span>millerRabinTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PublicKeyAlgorithmBox::millerRabinTest </td>
          <td>(</td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Die Methode <a class="el" href="classPublicKeyAlgorithmBox.html#a7dfad37e2a5370f0c001edf2d694e30d">millerRabinTest()</a> implementiert den Miller-Rabin Primzahltest. Dieser Algorithmus ist ein Monte Carlo Algorithmus. Ein Monte Carlo Algorithmus ist ein Algorithmus, der folgende Eigenschaften besitzt: Der Algorithmus bekommt als Eingabe eine beliebig lange Bitfolge und gibt als Ergebnis 0 oder 1 zurück; der Algorithmus hat Zugriff auf einen Zufallsgenerator, der Zufallsbits zurückliefert, die gleichverteilt sind; der Algorithmus berechnet das korrekte Ergebnis, mit der Wahrscheinlichkeit von (1/2) + Ɛ, wobei Ɛ &gt; 0. Der Miller-Rabin Primzahltest besitzt einen einseitigen Fehler. Wird eine Zahl von ihm als eine zusammengesetzte Zahl eingestuft, dann ist das Ergebnis zu 100 Prozent korrekt. Wird eine Zahl jedoch als Primzahl erkannt, dann ist das Ergebnis mit einer Wahrscheinlichkeit von 1-2^(-s) korrekt. Diese Fehlerwahrscheinlichkeit wird durch den Qualitätsparameter s beeiflusst, der angibt, wie viele zufällige Zahlen zwischen 1 und n-1 erzeugt werden und daraufhin überprüft werden, ob sie ein Solider Beweis sind, dass n eine zusammengesetzte Zahl ist.Die Laufzeit des Miller-Rabin Primzahltests beträgt O(log₂(n)³ * s). Eine Vorraussetzung für den Einsatz des Miller-Rabin Primzahltests sind kryptographisch gute Zufallszahlen. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Integer, für den untersucht werden soll, ob es sich um eine Primzahl oder um eine zusammengesetze Zahl handelt </td></tr>
    <tr><td class="paramname">s</td><td>Qualitätsparameter s, der angibt, wie oft die Schleife durchlaufen werden soll </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, wenn die Zahl eine Primzahl ist, False wenn die Zahl eine zusammengesetze Zahl ist </dd></dl>

</div>
</div>
<a id="a9fe8500da6a45e66caf4ffca7726cb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe8500da6a45e66caf4ffca7726cb16">&#9670;&nbsp;</a></span>modPrimeSqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PublicKeyAlgorithmBox::modPrimeSqrt </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>modPrimeSqrt berechnet die zwei Quadratwurzeln von y mod p, falls p kongruent zu 3 (mod 4) ist. Denn ist p eine Primzahl mit dieser Eigenschaft, dann ist y ein quadratischer Rest modulo p und die Gleichung y² = a (mod p) besitzt 2 Lösungen. Diese können durch (+-)a^((p-1)/4) mod p berechnet werden. Das berechnete Ergebnis wird im im Vektor v gespeichert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Das y bei y mod p, für welches die Quadratwurzeln berechnet werden. y ist ein Integer. </td></tr>
    <tr><td class="paramname">p</td><td>Das p bei y mod p, für welches die Quadratwurzeln berechnet werden. p ist ein Integer. Es werden nur Quadratwurzeln berechnet, wenn gilt, dass p kongruent zu 3 (mod 4) ist. Für ein richtiges Ergebnis muss p eine Primzahl sein. </td></tr>
    <tr><td class="paramname">v</td><td>v ist ein Vector aus Integern, in welchem die zwei Quadratwurzeln von y mod p gespeichert werden, falls p kongruent zu 3 (mod 4) ist, da dann genau zwei Quadratwurzeln für y existieren.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, falls die Quadratwurzeln berechnet wurden, ansonsten False. Die Quadratwurzeln können von dieser Funktion berechnet werden, falls p kongruent zu 3 (mod 4) ist. </dd></dl>

</div>
</div>
<a id="a422b73bfe57f6441757fc696410c3717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422b73bfe57f6441757fc696410c3717">&#9670;&nbsp;</a></span>modularExponentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Integer PublicKeyAlgorithmBox::modularExponentation </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>modularExponentation implementiert den Algorithmus zur modularen Exponentation. Dabei wird die Funktion a^b mod n effizient berechnet und das Ergebnis wird über den Rückgabewert als Integer zurückgeliefert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a für a^b mod n als Integer. </td></tr>
    <tr><td class="paramname">b</td><td>b für a^b mod n als Integer. </td></tr>
    <tr><td class="paramname">n</td><td>c für a^b mod n als Integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Das Ergebnis aus a^b mod n als Integer. </dd></dl>

</div>
</div>
<a id="a64680677e539d24b59e8873ec4fe3bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64680677e539d24b59e8873ec4fe3bb9">&#9670;&nbsp;</a></span>multInverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PublicKeyAlgorithmBox::multInverse </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>a_inv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>multInverse berechnet das multiplikative Inverse von a modulo n, vorausgesetzt ein solches existiert. Für ein multiplikatives Inverses a_inv von a gilt, dass a * a_inv ≡ 1 (mod n), da 1 dem neutralen Element der Multiplikation (mod n) entspricht. Die Methode liefert True zurück, wenn ein solches multiplikatives Inverses existiert und False wenn nicht. Ein a ist invertierbar modulo n, wenn gcd(a,n) = 1, also a und n teilerfremd zu einander sind. gcd(a,n) kann auch mit dem Erweiterten Algorithmus von Euklid berechnet werden. Wegen ZTK Satz 3.4 gibt es x,y ∈ Z, so dass gcd(a, n) = 1 = ax + ny. Somit gilt 1 ist kongruent zu ax+ny (mod n). Wegen mod n kürzt sich das ny raus und ist somit das gleiche wie 1 ist kongruent zu ax (mod n). Dadurch ist x das multiplikative Inverse von a mod n und dieses x kann ebenfalls durch den Erweiterten Euklidschen Algorithmus berechnet werden. Es werden keine negativen Inversen zurückgegeben.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Das a, für welches das multiplikative Inverse a mod n berechnet wird. a ist ein Integer. </td></tr>
    <tr><td class="paramname">n</td><td>Das n, für welches das multiplikative Inverse a mod n berechnet wird. n ist ein Integer. </td></tr>
    <tr><td class="paramname">a_inv</td><td>a_inv ist ein Integer, in welchem diese Funktion das multiplikative Inverse von a modulo n speichert, wenn ein solches multiplikatives Inverses existiert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, wenn ein multiplikatives Inverses von a mod n existiert. False, wenn nicht. </dd></dl>

</div>
</div>
<a id="a598a7a28b29517a85daeb50b560a895d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598a7a28b29517a85daeb50b560a895d">&#9670;&nbsp;</a></span>randomInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Integer PublicKeyAlgorithmBox::randomInteger </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>randomInteger liefert einen zufälligen Integer im Bereich 0,1,...,n-1 zurück.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>n gibt die Obergrenze des zu generierenden Integers an. n ist exklusiv, das heißt der generierte Integer ist &lt; n. n ist vom Typ Integer und muss größer als 0 sein. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Einen zufälligen Integer im Bereich 0,1,...,n-1 </dd></dl>

</div>
</div>
<a id="ae1860632778c07e3990406413cda154f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1860632778c07e3990406413cda154f">&#9670;&nbsp;</a></span>randomPrime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int PublicKeyAlgorithmBox::randomPrime </td>
          <td>(</td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bitlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>randomPrime generiert eine Zahl, die mit Wahrscheinlichkeit 1-2^-s eine Primzahl ist und speichert diese Zahl im Parameter p ab. Die generierte Zahl hat ebenfalls eine maximale Größe in Binardarstellung von bitlen Ziffern/Bits. Die generierte Zahl wird mit einem Nicht Blockierenden Pseudozufallszahlengenerator generiert und mit dem Rabin Miller Test überprüft, ob es sich dabei mit Wahrscheinlichkeit 1-2^-s um eine Primzahl handelt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>In p wird die generierte Zahl als Integer abgespeichert. </td></tr>
    <tr><td class="paramname">bitlen</td><td>bitlen gibt die Größe der zu erzeugenden Zahl in Bits an. </td></tr>
    <tr><td class="paramname">s</td><td>s ist das s in 1-2^-s, welches die Wahrscheinlichkeit dafür angibt, dass p tatsächlich eine Primzahl ist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>randomPrime gibt die Anzahl der generierten Zufallszahlen zurück, die überprüft worden sind, bis eine dieser Zufallszahlen als wahrscheinlich Prime evaluiert wurde. </dd></dl>

</div>
</div>
<a id="aea85d2370877359f5cfaf977d1e8c94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea85d2370877359f5cfaf977d1e8c94e">&#9670;&nbsp;</a></span>randomRabinPrime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int PublicKeyAlgorithmBox::randomRabinPrime </td>
          <td>(</td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bitlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>randomRabinPrime generiert mit Fehlerwahrscheinlichkeit 2^-s eine Zufallsprimzahl mit folgenden Eigenschaften:</p><ul>
<li>Die Binärdarstellung von p hat höchstens bitlen Bits.</li>
<li>p ist eine Rabin-Primzahl, ð, für die gilt p ≡ 3 (mod 4). Die Methode speichert die erzeugte Rabin-Primzahl in p ab.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>In Variable p wird die generierte Rabin-Primzahl abgespeichert. </td></tr>
    <tr><td class="paramname">bitlen</td><td>bitlen gibt die maximale Größe der zu erzeugenden Primzahl in Bits an. </td></tr>
    <tr><td class="paramname">s</td><td>s ist das s in 2^-s, welches die Fehlerwahrscheinlichkeit angibt, dass der zurückgelieferte Wert in p keine Primzahl ist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Die Anzahl der Versuche, bis eine Rabin Primzahl gewürfelt worden ist. </dd></dl>

</div>
</div>
<a id="a44ae652ebf981342dc04fedf80b0a5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ae652ebf981342dc04fedf80b0a5bc">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PublicKeyAlgorithmBox::sqrt </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sqrt versucht die kleinste nicht-negativen ganzzahligen Quadratwurzel s von x zu berechnen. Wird diese gefunden, dann wird true zurückgegeben. Andernfalls wird false zurückgegeben. Der Algorithmus sucht in Logarithmischer Zeit mit der binären Suche nach s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Die Zahl als Integer, für welche die kleinste nicht negative ganzzahlige Quadratwurzel gesucht werden soll. </td></tr>
    <tr><td class="paramname">s</td><td>Wird die kleinste nicht negative ganzzahlige Quadratwurzel von x gefunden, dann wird diese von dieser Methode in s geschrieben. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, falls die kleinste nicht negative ganzzahlige Quadratwurzel gefunden wurde, false wenn nicht. </dd></dl>

</div>
</div>
<a id="a04cf3ae489af192f0378fe418555f577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cf3ae489af192f0378fe418555f577">&#9670;&nbsp;</a></span>witness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PublicKeyAlgorithmBox::witness </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Der Algorithmus witness ist eine abgewandelte Form der modularen Exponentiation, die für die übergebenen Parameter a und n den Term a^(n-1) (mod n) berechnet. Diese Berechnung soll den Satz von Fermat überprüfen. Der Satz von Fermat sagt aus: Ist n eine Primzahl, dann gilt für alle a in Z Stern n, dass: a^(n-1) kongruent zu 1 (mod n). Wenn das Ergebnis dieser Berechnung ungleich 1 ist, dann ist die Zahl definitiv keine Primzahl und a kann als Solider Beweis dafür angesehen werden, dass n keine Primzahl ist. Ein solider Beweis ist eine Zahl a in Z Stern n, die beweist, dass n eine zusammengesetzte Zahl ist. Sei n also eine beliebige ungerade natürliche Zahl, die größer 1 ist. Dann werden r und u so gewählt, dass n-1 = 2^r * u ist. Dann ist a ein solider Beweis, falls: 1. a^u nicht kongruent zu +1 oder -1 (modulo n) und 2. Für alle i=1 bis r-1 gilt: a ^(2^i * u) ist nicht kongruent zu -1 (modulo n). Wenn n eine beliebige, zusammengesetzte Zahl ist, die keine Primzahlpotenz ist, dann sind mindestens die Hälfte aller Zahlen in Z Stern n solide Beweise dafür, dass n eine zusammengesetzte Zahl ist. Ist das Ergebnis der Berechung des Fermat-Kriteriums a^(n-1) (mod n) jedoch gleich 1, dann ist es möglich, dass die Zahl eine Primzahl ist. Es existieren jedoch auch Carmichael Zahlen. Für diese seltenen, zusammengesetzten Zahlen gilt: Sei c eine Charmichael Zahl, dann gilt für alle a in Z Stern c, dass a^(n-1) kongruent zu 1 (modulo n). Deshalb reicht der Satz von Fermat allein nicht aus, um eine Primzahl zu erkennen. Deshalb wird während der Berechnung von a^(n-1) parallel dabei nach einer Lösung für die Gleichung x^2 kongruent zu 1 (mod n) gesucht, die verschieden zu 1 und -1 (also n-1) ist. Wird eine solche Zahl gefunden, dann ist a ein Solider Beweis dafür, dass n keine Primzahl ist. Diese Schlussfolgerung ist möglich, da wenn n eine Primzahl ungleich 2 ist, dann sind 1 und -1 die einzigen Quadratwurzeln von 1 (mod n) in Z Stern n. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Zahl in Z Stern n, für die überprüft wird, ob sie ein soldier Beweis dafür ist, dass n eine zusammengesetzte Zahl ist </td></tr>
    <tr><td class="paramname">n</td><td>Zahl, für die getestet werden soll, ob sie eine Primzahl ist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, wenn n keine Primzahl ist (a also ein Solider Beweis ist), ansonsten False </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/daniel/K/Crypto/AK/src/Praktikum-Public-Key/<a class="el" href="PublicKeyAlgorithmBox_8h_source.html">PublicKeyAlgorithmBox.h</a></li>
<li>/home/daniel/K/Crypto/AK/src/Praktikum-Public-Key/PublicKeyAlgorithmBox.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
