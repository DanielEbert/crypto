<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: RSADecryptor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classRSADecryptor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RSADecryptor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="RSADecryptor_8h_source.html">RSADecryptor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67080d488614ac02e0c5d14757e091da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRSADecryptor.html#a67080d488614ac02e0c5d14757e091da">RSADecryptor</a> (const Integer &amp;<a class="el" href="classRSADecryptor.html#a16836808c617c03ef77eebab53a968dc">p</a>, const Integer &amp;<a class="el" href="classRSADecryptor.html#ada5ca374710fa8da920fab41eee66f89">q</a>, const Integer &amp;<a class="el" href="classRSADecryptor.html#a3186dbd03ad5dc7e4dc280dacf7bf467">d</a>)</td></tr>
<tr class="separator:a67080d488614ac02e0c5d14757e091da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee233bf5e3c49162a1cb93e226652f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRSADecryptor.html#a9ee233bf5e3c49162a1cb93e226652f4">compute</a> (const Integer &amp;y, Integer &amp;x) const</td></tr>
<tr class="separator:a9ee233bf5e3c49162a1cb93e226652f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd0662ced1a487d0dd95a4b4f5bfd40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRSADecryptor.html#a5bd0662ced1a487d0dd95a4b4f5bfd40">crt</a> (const Integer &amp;y, Integer &amp;x) const</td></tr>
<tr class="separator:a5bd0662ced1a487d0dd95a4b4f5bfd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ab037597888e528629dcde3bcdf570"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRSADecryptor.html#a65ab037597888e528629dcde3bcdf570">garner</a> (const Integer &amp;y, Integer &amp;x) const</td></tr>
<tr class="separator:a65ab037597888e528629dcde3bcdf570"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a16836808c617c03ef77eebab53a968dc"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRSADecryptor.html#a16836808c617c03ef77eebab53a968dc">p</a></td></tr>
<tr class="separator:a16836808c617c03ef77eebab53a968dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5ca374710fa8da920fab41eee66f89"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRSADecryptor.html#ada5ca374710fa8da920fab41eee66f89">q</a></td></tr>
<tr class="separator:ada5ca374710fa8da920fab41eee66f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3186dbd03ad5dc7e4dc280dacf7bf467"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRSADecryptor.html#a3186dbd03ad5dc7e4dc280dacf7bf467">d</a></td></tr>
<tr class="separator:a3186dbd03ad5dc7e4dc280dacf7bf467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9edac5888c94d38a2e3dbe6b55dd96"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRSADecryptor.html#a8a9edac5888c94d38a2e3dbe6b55dd96">n</a></td></tr>
<tr class="separator:a8a9edac5888c94d38a2e3dbe6b55dd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Die Klasse <a class="el" href="classRSADecryptor.html">RSADecryptor</a> bietet Methoden an, um einen mit RSA verschlüsselten Geheimtext zu entschlüsseln. Der Geheimtext muss mit dem Öffentlichen Schlüssel n und e verschlüsselt worden sein, wobei gelten muss, dass n = p * q und das e * d ≡ 1 (mod ϕ(n)), d also das multiplikative Inverse von e (mod ϕ(n)) ist. Die Sicherheit von RSA beruht auf dem Faktorisierungsproblem und dem Invertieren der modularen Potenzfunktion. Für keines der beiden Probleme ist ein Polynomialzeit Algorithmus bekannt. Könnten diese Probleme in effizienter Laufzeit gelöst werden, dann ist RSA nicht mehr sicher. Beim Faktorisierungsproblem ist eine zusammengesetzte Zahl n gegeben. Gesucht ist ein Faktor f von n, d.h eine Zahl f mit den Eigenschaften: 1 &lt; f &lt; n und f | n. Die modulare Potenzfunktion ist eine Einwegfunktion und ist deshalb schwierig zu invertieren. Zusätzlich hängt die Sicherheit von der Qualität der Schlüssel und der Geheimhaltung des privaten Schlüssels ab. Mit dem aktuellen Stand der Technik werden mindestens 2048 Bit pro p und q vorgeschlagen. RSA ist ein Public Key Kryptosystem. Da die zur Verschlüsselung benötigten Parameter öffentlich sind, kann jeder eine verschlüsselte Nachricht versenden. Bei hinreichend langer Schlüssellänge und guter Wahl der Parameter gilt RSA als sicheres Kryptosystem. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a67080d488614ac02e0c5d14757e091da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67080d488614ac02e0c5d14757e091da">&#9670;&nbsp;</a></span>RSADecryptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RSADecryptor::RSADecryptor </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Konstruktor der <a class="el" href="classRSADecryptor.html">RSADecryptor</a> Klasse, welche den privaten Teil des Schlüssels, p, q und d setzt. Die Übergabeargumente werden den Klassenvariablen p, q und d zugewiesen. Das n wird ebenfalls gemäß der RSA-Spezifikation durch p * q berechnet. n ist ein Teil des öffentlichen Schlüssels und gibt mit Z_n den Klartext- und Geheimtextraum vor. Die Parameter werden nicht auf Korrektheit hin überprüft, also wird nicht überprüft, ob p und q tatsächlich mit einer ausreichenden Wahrscheinlichkeit Primzahlen sind und ebenfalls nicht, ob p == q ist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>p ist ein Teil des privaten Schlüssels. p muss eine Primzahl sein, das wird allerdings nicht überprüft. p ist ein Integer. </td></tr>
    <tr><td class="paramname">q</td><td>q ist ein Teil des privaten Schlüssels. q muss eine Primzahl sein, das wird allerdings nicht überprüft. q ist ein Integer. </td></tr>
    <tr><td class="paramname">d</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9ee233bf5e3c49162a1cb93e226652f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee233bf5e3c49162a1cb93e226652f4">&#9670;&nbsp;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RSADecryptor::compute </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute entschlüsselt den Integer y mit dem n des öffentlichen Schlüssels und dem Privaten Teil d. Bei dieser Implementation der Entschlüsselung wird die zu entschlüsselnde Zahl y mit y^d mod n entschlüsselt. Das Ergebnis ist das entschlüsselte y, welches im Parameter x gespeichert wird. Die Zahl y muss &lt; n sein, weil y sonst nicht Teil des Geheimtextraums ist. Sei x der originale Klartext. Wenn x mit x^e mod n = y verschlüsselt wurde, dann kann der daraus resultierende Ciphertext y mit y^d mod n entschlüsselt werden. Der Grund dafür ist, dass laut Vorgabe e * d ≡ 1 (mod ϕ(n)) gelten muss. y = (x^e)^d = x^(e*d) Mit dem Satz von Fermat kann gezeigt werden, dass x^(e*d) ≡ x (mod p) und x^(e*d) ≡ x (mod q) für alle x ∈ Z_n ist. Somit ist der entschlüsselte Text der gleiche wie der originale Klartext x. Da n = p*q kann mit dem Chinesischen Restsatz gezeigt werden, dass x^(e*d) ≡ x (mod n). Der Chinesischen Restsatz kann verwendet werden, weil gcd(p,q) = 1 ist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Die zu entschlüsselnde Zahl als Integer. y muss ein Element des Geheimtextraums sein. </td></tr>
    <tr><td class="paramname">x</td><td>Wenn entschlüsselt werden kann, dann wird das entschlüsselte y in x als Integer gespeichert. x wird ein Element des Klartextraums sein. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, wenn entschlüsselt werden konnte, also y &lt; n gilt, False wenn nicht. </dd></dl>

</div>
</div>
<a id="a5bd0662ced1a487d0dd95a4b4f5bfd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd0662ced1a487d0dd95a4b4f5bfd40">&#9670;&nbsp;</a></span>crt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RSADecryptor::crt </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute entschlüsselt den Integer y mit dem Öffentlichen Teil n und dem Privaten Teil d. Bei der Implementierung der Entschlüsselung in dieser Methode wird die zu entschlüsselnde Zahl y mit dem Chinesischen Restsatz entschlüsselt. Alternativ zu x ≡ y^d % n kann mit: x ≡ y^d % p x ≡ y^d % q und dem Chinesischen Restsatz entschlüsselt weden, weil gcd(p,q) = 1 ist. Das ist möglich, weil die Faktoren p und q für n zum einen bekannt sind, und zum anderen weil gcd(p,q) = 1 ist, was die Vorbedingung für den Einsatz des CRT ist. Die Anwendung des CRT wird im .cpp Teil dieser Methode erläutert. Das Ergebnis ist das entschlüsselte y, welches im Parameter x gespeichert wird. Die Zahl y muss &lt; n sein, weil sonst y nicht innerhalb des Geheimtextraums liegt. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Die zu entschlüsselnde Zahl als Integer. y muss ein Element des Geheimtextraums sein. </td></tr>
    <tr><td class="paramname">x</td><td>Wenn entschlüsselt werden kann, dann wird das entschlüsselte y in x als Integer gespeichert. x wird ein Element des Klartextraums sein. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, wenn entschlüsselt werden konnte, also y &lt; n gilt, False wenn nicht. </dd></dl>

</div>
</div>
<a id="a65ab037597888e528629dcde3bcdf570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ab037597888e528629dcde3bcdf570">&#9670;&nbsp;</a></span>garner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RSADecryptor::garner </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute entschlüsselt den Integer y mit dem Öffentlichen Teil n und dem Privaten Teil d. Bei der Implementierung der Entschlüsselung in dieser Methode wird die zu entschlüsselnde Zahl y mit Garners Verfahren entschlüsselt, welches eine effiziente Entschlüsselung des Geheimtexts erlaubt. Das Ergebnis ist das entschlüsselte y, welches im Parameter x gespeichert wird. Die Zahl y muss &lt; n sein, weil sonst y nicht Teil des Geheimtextraums ist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Die zu entschlüsselnde Zahl als Integer. y muss ein Element des Geheimtextraums sein. </td></tr>
    <tr><td class="paramname">x</td><td>Wenn entschlüsselt werden kann, dann wird das entschlüsselte y in x als Integer gespeichert. x ist ein Element innerhalb des Klartextraums Zn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, wenn entschlüsselt werden konnte, also y &lt; n gilt, False wenn nicht. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3186dbd03ad5dc7e4dc280dacf7bf467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3186dbd03ad5dc7e4dc280dacf7bf467">&#9670;&nbsp;</a></span>d</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Integer RSADecryptor::d</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>d ist ein Teil des privaten Schlüssels. d muss das multiplikative Inverse von e mod ϕ(n) sein. Das wird von dieser Klasse allerdings nicht überprüft. e ist Teil des Öffentlichen Schlüssels. </p>

</div>
</div>
<a id="a8a9edac5888c94d38a2e3dbe6b55dd96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9edac5888c94d38a2e3dbe6b55dd96">&#9670;&nbsp;</a></span>n</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Integer RSADecryptor::n</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>n ist ein Teil des öffentlichen Schlüssels. n wird durch p * q im Konstruktor berechnet. n wird sowohl bei der Ver- als auch bei der Entschlüsselung verwendet und gibt die Größe des Klartextraums und Geheimtextraums an, der Z_n ist. </p>

</div>
</div>
<a id="a16836808c617c03ef77eebab53a968dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16836808c617c03ef77eebab53a968dc">&#9670;&nbsp;</a></span>p</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Integer RSADecryptor::p</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>p ist ein Teil des privaten Schlüssels. p muss eine Primzahl sein, dies wird von dieser Klasse allerdings nicht überprüft. Es muss p != q gelten, das wird allerdings ebenfalls nicht überprüft. </p>

</div>
</div>
<a id="ada5ca374710fa8da920fab41eee66f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5ca374710fa8da920fab41eee66f89">&#9670;&nbsp;</a></span>q</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Integer RSADecryptor::q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>q ist ein Teil des privaten Schlüssels. q muss eine Primzahl sein, dies wird von dieser Klasse allerdings nicht überprüft. Es muss p != q gelten, das wird allerdings ebenfalls nicht überprüft. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/daniel/K/Crypto/AK/src/Praktikum-Public-Key/<a class="el" href="RSADecryptor_8h_source.html">RSADecryptor.h</a></li>
<li>/home/daniel/K/Crypto/AK/src/Praktikum-Public-Key/RSADecryptor.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
