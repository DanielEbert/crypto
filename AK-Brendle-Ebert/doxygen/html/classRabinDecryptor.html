<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: RabinDecryptor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classRabinDecryptor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RabinDecryptor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="RabinDecryptor_8h_source.html">RabinDecryptor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a56a1adf9fd4003c2745aaba0ea14ea15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRabinDecryptor.html#a56a1adf9fd4003c2745aaba0ea14ea15">RabinDecryptor</a> (const Integer &amp;<a class="el" href="classRabinDecryptor.html#a4cd8cb3986c5c573acf4b3d2a20308f2">p</a>, const Integer &amp;<a class="el" href="classRabinDecryptor.html#ae9b626921f3f18eaf2dc6b9d05ba4fc5">q</a>, const Integer &amp;<a class="el" href="classRabinDecryptor.html#ad52ea9bb778a099c16947ade81f0d833">padding</a>=Integer(&quot;987654321&quot;))</td></tr>
<tr class="separator:a56a1adf9fd4003c2745aaba0ea14ea15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a06f8622ddcc29f95cb8ec3f36f5ad8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRabinDecryptor.html#a3a06f8622ddcc29f95cb8ec3f36f5ad8">compute</a> (const Integer &amp;y, vector&lt; Integer &gt; &amp;xv)</td></tr>
<tr class="separator:a3a06f8622ddcc29f95cb8ec3f36f5ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87cfb506abc1a93ba01261a9f5c8e93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRabinDecryptor.html#af87cfb506abc1a93ba01261a9f5c8e93">compute</a> (const Integer &amp;y, Integer &amp;x)</td></tr>
<tr class="separator:af87cfb506abc1a93ba01261a9f5c8e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e00afa61dfbc78166e058690bf6b62b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRabinDecryptor.html#a7e00afa61dfbc78166e058690bf6b62b">compute2</a> (const Integer &amp;y, Integer &amp;x)</td></tr>
<tr class="separator:a7e00afa61dfbc78166e058690bf6b62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4cd8cb3986c5c573acf4b3d2a20308f2"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRabinDecryptor.html#a4cd8cb3986c5c573acf4b3d2a20308f2">p</a></td></tr>
<tr class="separator:a4cd8cb3986c5c573acf4b3d2a20308f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b626921f3f18eaf2dc6b9d05ba4fc5"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRabinDecryptor.html#ae9b626921f3f18eaf2dc6b9d05ba4fc5">q</a></td></tr>
<tr class="separator:ae9b626921f3f18eaf2dc6b9d05ba4fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52ea9bb778a099c16947ade81f0d833"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRabinDecryptor.html#ad52ea9bb778a099c16947ade81f0d833">padding</a></td></tr>
<tr class="separator:ad52ea9bb778a099c16947ade81f0d833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2b4ad7ecd191108e91526696765d9a"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRabinDecryptor.html#a2d2b4ad7ecd191108e91526696765d9a">offset</a></td></tr>
<tr class="separator:a2d2b4ad7ecd191108e91526696765d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classRabinDecryptor.html">RabinDecryptor</a> stellt Methoden bereit, um eine Zahl in einem Integer mit dem Rabin Kryptosystem zu entschlüsseln. Es gibt zusätzlich die Möglichkeit, über einen mit dem padding endenden verschlüsselten Klartext aus den 4 möglichen, aus der Entschlüsselung resultierenden, Klartexten zu bestimmen. Wurde am Ende des Klartexts ein Padding hinzugefügt, dann wird das in dieser Dokumentation als markieren des Klartextes bezeichnet. Markiert bedeutet, dass das padding an das Ende der zu verschlüsselnden Zahl angehangen wird und dann erst wird "x||padding" verschlüsselt. Der Grund dafür ist, dass es bei der Entschlüsselung einer verschlüsselten Zahl 4 verschiedene Möglichkeiten gibt und nur eine davon ist der ursprüngliche Klartext. Es gibt genau 4 mögliche Klartexte, da gilt, dass wenn n das Produkt zweier Rabin-Primzahlen ist, für Gleichung x² ≡ a (mod n) genau 4 Lösungen existieren. Da bei Markierung das padding beiden Parteien bekannt ist, erhält die entschlüsselnde Partei durch das Padding einen Hinweis darauf, welches der 4 entschlüsselten Möglichkeiten der originale Klartext sein könnte. Das Rabin Kryptosystem ist anfällig gegen eine Chosen-Ciphertext-Attacke. Durch das Padding kann ebenfalls ein Angriff dieser Art allerdings abgewehrt werden. Es ist möglich, dass mehr als einer der 4 entschlüsselten Möglichkeiten mit dem Padding endet. Die Wahrscheinlichkeit dafür sinkt bei größerem Padding. Das Rabin Kryptosystem ist ein Public Key Kryptosystem, dessen Sicherheit vom Faktorisierungsproblem abhängt. Beim Faktorisierungsproblem ist eine zusammengesetzte Zahl n gegeben. Gesucht ist ein Faktor f von n, d.h eine Zahl f mit den Eigenschaften: 1 &lt; f &lt; n und f | n. Das Rabin Kryptosystem ist beweisbar sicher. Es hat eine geringe Bedeutung für die Praxis, da zum Beispiel ein erhöhter Aufwand bei der Entschlüsselung aufgrund der nicht injektiven Verschlüsselungsfunktion entsteht. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a56a1adf9fd4003c2745aaba0ea14ea15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a1adf9fd4003c2745aaba0ea14ea15">&#9670;&nbsp;</a></span>RabinDecryptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RabinDecryptor::RabinDecryptor </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>padding</em> = <code>Integer(&quot;987654321&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Konstruktor der <a class="el" href="classRabinDecryptor.html">RabinDecryptor</a> Klasse, welcher die Klassenvariablen p, q, offset, und padding setzt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>p soll eine Rabin Primzahl (p ≡ 3 (mod 4)) und verschieden zu q sein. p wird Teil des privaten Schlüssels. Der Konstruktor überprüft jedoch nicht, ob es sich bei p tatsächlich um eine Rabin-Primzahl handelt. </td></tr>
    <tr><td class="paramname">q</td><td>q soll eine Rabin Primzahl (q ≡ 3 (mod 4)) und verschieden zu p sein. q wird Teil des privaten Schlüssels. Es muss jedoch vom aufrufenden Programm sichergestellt werden, dass es sich um eine Rabin-Primzahl handelt. </td></tr>
    <tr><td class="paramname">padding</td><td>Ist ein Wert, mit dem ein zu verschlüsselnder Text markiert wurde. Markiert bedeutet, dass das padding an das Ende des zu verschlüsselten Texts angehangen worden ist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3a06f8622ddcc29f95cb8ec3f36f5ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a06f8622ddcc29f95cb8ec3f36f5ad8">&#9670;&nbsp;</a></span>compute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RabinDecryptor::compute </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>xv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute Entschlüsselt den Geheimtext y und speichert die 4 möglichen Klartexte im Vektor xv ab. Es wird nicht auf das padding am Ende der möglichen Klartexte überprüft. Zu beachten gilt es, dass 4 mögliche Klartexte zurückgeliefert werden und diese Methode nicht bestimmt, welches der 4 möglichen Klartexte der tatsächliche Klartext ist. Zur Entschlüsselung muss die Wurzel von y modulo n berechnet werden. Diese Berechnung ist durchführbar, wenn die beiden Rabin-Primzahlen p und q des privaten Schlüssels bekannt sind. Grundlage der Entschlüsselung ist der Satz, dass die beiden Lösungen der Gleichung x² ≡ a (mod p), wenn p eine eine Rabin-Primzahl ist, durch die Formel: x1/2 = (+/-) a^((p-1)/4) mod p berechnet werden kann. Die Entschlüsselung des Rabin-Kryptosystems findet dann folgendermaßen statt: Zuerst werden die Lösungen der Gleichungen a² ≡ y (mod p) und b² ≡ y (mod q) berechnet. Anschließend werden mit Hilfe des Chinesischen Restsatzes die vier möglichen Lösungen der Gleichung v² ≡ y (mod p*q) berechnet. Der Chinesische Restsatz kann angewandt werden, da gcd(p,q) = 1. Das funktioniert, weil y aus x² mod n entstanden ist und somit ist y ein quadratischer Rest modulo n. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>y ist der zu entschlüsselnde Geheimtext bzw. die zu entschlüsselnde Zahl als Integer. y muss ein Element des Geheimtextraums sein. </td></tr>
    <tr><td class="paramname">xv</td><td>xv ist ein Vektor von Integern, in welchen bei erfolgreicher Entschlüsselung die 4 möglichen Klartexte abgespeichert werden. Jeder dieser Integer ist ein Element des Klartextraums. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, wenn das Entschlüsseln erfolgreich war, false wenn nicht. </dd></dl>

</div>
</div>
<a id="af87cfb506abc1a93ba01261a9f5c8e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87cfb506abc1a93ba01261a9f5c8e93">&#9670;&nbsp;</a></span>compute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RabinDecryptor::compute </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute Entschlüsselt den Geheimtext y. Zu beachten gilt es, dass 4 mögliche Klartexte resultieren werden und diese Methode nicht bestimmt, welches der 4 möglichen Klartexte der tatsächliche Klartext ist. Stattdessen wird einer dieser 4 möglichen Klartexte zurückgegeben. Zur Entschlüsselung muss die Wurzel von y modulo n berechnet werden. Diese Berechnung ist durchführbar, wenn die beiden Rabin-Primzahlen p und q des privaten Schlüssels bekannt sind. Grundlage der Entschlüsselung ist der Satz, dass die beiden Lösungen der Gleichung x² ≡ a (mod p), wenn p eine eine Rabin-Primzahl ist, durch die Formel: x1/2 = (+/-) a^((p-1)/4) mod p berechnet werden kann. Die Entschlüsselung des Rabin-Kryptosystems findet dann folgendermaßen statt: Zuerst werden die Lösungen der Gleichungen a² ≡ y (mod p) und b² ≡ y (mod q) berechnet. Anschließend werden mit Hilfe des Chinesischen Restsatzes die vier möglichen Lösungen der Gleichung v² ≡ y (mod p*q) berechnet. Der Chinesische Restsatz kann angewandt werden, da gcd(p,q) = 1. Das funktioniert, weil y aus x² mod n entstanden ist und somit ist y ein quadratischer Rest modulo n. Es wird nicht nach einem padding in den möglichen Klartexten hin überprüft. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>y ist der zu entschlüsselnde Geheimtext bzw. die zu entschlüsselnde Zahl als Integer. y muss ein Element des Geheimtextraums sein. </td></tr>
    <tr><td class="paramname">x</td><td>x ist ein Integern, in welchem bei erfolgreicher entschlüsselung eines der 4 möglichen Klartexte abgespeichert wird. x ist ein Element des Klartextraums. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, wenn das entschlüsseln erfolgreich war, false wenn nicht. </dd></dl>

</div>
</div>
<a id="a7e00afa61dfbc78166e058690bf6b62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e00afa61dfbc78166e058690bf6b62b">&#9670;&nbsp;</a></span>compute2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RabinDecryptor::compute2 </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute2 Entschlüsselt den Geheimtext y. Zu beachten gilt es, dass 4 mögliche Klartexte aus der Entschlüsselung resultieren. Zur Entschlüsselung muss die Wurzel von y modulo n berechnet werden. Diese Berechnung ist durchführbar, wenn die beiden Rabin-Primzahlen p und q des privaten Schlüssels bekannt sind. Grundlage der Entschlüsselung ist der Satz, dass die beiden Lösungen der Gleichung x² ≡ a (mod p), wenn p eine eine Rabin-Primzahl ist, durch die Formel: x1/2 = (+/-) a^((p-1)/4) mod p berechnet werden kann. Die Entschlüsselung des Rabin-Kryptosystems findet dann folgendermaßen statt: Zuerst werden die Lösungen der Gleichungen a² ≡ y (mod p) und b² ≡ y (mod q) berechnet. Anschließend werden mit Hilfe des Chinesischen Restsatzes die vier möglichen Lösungen der Gleichung v² ≡ y (mod p*q) berechnet. Der Chinesische Restsatz kann angewandt werden, da gcd(p,q) = 1. Das funktioniert, weil y aus x² mod n entstanden ist und somit ist y ein quadratischer Rest modulo n. Zusätzlich zu compute überprüft compute2, ob einer dieser 4 Klartexte in Dezimaldarstellung mit dem padding endet. Das padding wird als Markierung gesehen, welches den Klartext markiert. compute2 speichert bei Erfolg den Klartext ohne padding im Integer x. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>y ist der zu entschlüsselnde Geheimtext bzw. die zu entschlüsselnde Zahl als Integer. y muss ein Element des Klartextraums sein. </td></tr>
    <tr><td class="paramname">x</td><td>x ist ein Integer, in welchem bei Erfolg der entschlüsselte Klartext ohne padding gespeichert wird. x wird ein Element des Klartextraums sein. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, wenn das Entschlüsseln erfolgreich war, false wenn nicht. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2d2b4ad7ecd191108e91526696765d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2b4ad7ecd191108e91526696765d9a">&#9670;&nbsp;</a></span>offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Integer RabinDecryptor::offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>offset stellt die Zahl dar, mit der ein zu verschlüsselnder Text/Zahl multipliziert werden muss, damit das padding auf dieses Produkt addiert werden kann und in Dezimaldarstellung die letzten x Ziffern belegt, wobei x die Anzahl der Ziffern des paddings in Dezimaldarstellung ist. Zum Beispiel, wenn padding = 987 ist, dann ist offset = 1000. Ein zu verschlüsselnder Geheimtext a = 123 kann dann mit a * offset + padding = 123987 markiert werden. Weiter kann mit y % offset == padding, wobei y ein möglicher Klartext ist, erkannt werden, ob dieser mögliche Klartext mit dem padding endet. Das kann ein Hinweis darauf sein, dass der Klartext markiert worden ist. Es kann aber auch sein, dass einer der möglichen Klartexte nur zufällig mit dem padding endet. Wenn das Padding zum markieren von Klartexten verwendet werden soll, dann muss das Padding beim Ver- und Entschlüsseln bekannt sein. </p>

</div>
</div>
<a id="a4cd8cb3986c5c573acf4b3d2a20308f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd8cb3986c5c573acf4b3d2a20308f2">&#9670;&nbsp;</a></span>p</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Integer RabinDecryptor::p</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>p ist eine Rabin Primzahl. Dabei gilt, dass p ≡ 3 (mod 4) ist. p ist Teil des privaten Schlüssels. Es muss p * q = n und p != q gelten. </p>

</div>
</div>
<a id="ad52ea9bb778a099c16947ade81f0d833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52ea9bb778a099c16947ade81f0d833">&#9670;&nbsp;</a></span>padding</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Integer RabinDecryptor::padding</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>offset stellt die Zahl dar, mit der ein zu verschlüsselnder Text/Zahl multipliziert werden muss, damit das padding auf dieses Produkt addiert werden kann und in Dezimaldarstellung die letzten x Ziffern belegt, wobei x die Anzahl der Ziffern des paddings in Dezimaldarstellung ist. Zum Beispiel, wenn padding = 987 ist, dann ist offset = 1000. Ein zu verschlüsselnder Geheimtext a = 123 kann dann mit a * offset + padding = 123987 markiert werden. Weiter kann mit y % offset == padding, wobei y ein möglicher Klartext ist, erkannt werden, ob dieser mögliche Klartext mit dem padding endet. Das kann ein Hinweis darauf sein, dass der Klartext markiert worden ist. Es kann aber auch sein, dass einer der möglichen Klartexte nur zufällig mit dem padding endet. </p>

</div>
</div>
<a id="ae9b626921f3f18eaf2dc6b9d05ba4fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b626921f3f18eaf2dc6b9d05ba4fc5">&#9670;&nbsp;</a></span>q</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Integer RabinDecryptor::q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>q ist eine Rabin Primzahl. Dabei gilt, dass q ≡ 3 (mod 4) ist. q ist Teil des privaten Schlüssels. p * q = n und p != q müssen gelten. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/daniel/K/Crypto/AK/src/Praktikum-Public-Key/<a class="el" href="RabinDecryptor_8h_source.html">RabinDecryptor.h</a></li>
<li>/home/daniel/K/Crypto/AK/src/Praktikum-Public-Key/RabinDecryptor.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
