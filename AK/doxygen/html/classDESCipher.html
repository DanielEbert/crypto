<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: DESCipher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classDESCipher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DESCipher Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for DESCipher:</div>
<div class="dyncontent">
<div class="center"><img src="classDESCipher__inherit__graph.png" border="0" usemap="#DESCipher_inherit__map" alt="Inheritance graph"/></div>
<map name="DESCipher_inherit__map" id="DESCipher_inherit__map">
<area shape="rect" id="node2" href="classBlockCipher.html" title="BlockCipher" alt="" coords="5,5,99,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for DESCipher:</div>
<div class="dyncontent">
<div class="center"><img src="classDESCipher__coll__graph.png" border="0" usemap="#DESCipher_coll__map" alt="Collaboration graph"/></div>
<map name="DESCipher_coll__map" id="DESCipher_coll__map">
<area shape="rect" id="node2" href="classBlockCipher.html" title="BlockCipher" alt="" coords="5,5,99,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a296b6450dbdf2c35c70c74c628d9176b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a296b6450dbdf2c35c70c74c628d9176b">DESCipher</a> ()</td></tr>
<tr class="separator:a296b6450dbdf2c35c70c74c628d9176b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a6522ce5c469bfb055e1005ca03fbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#ab2a6522ce5c469bfb055e1005ca03fbf">~DESCipher</a> ()</td></tr>
<tr class="separator:ab2a6522ce5c469bfb055e1005ca03fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc960554f1e80092e62730769b9220b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a7dc960554f1e80092e62730769b9220b">computeKeySchedule</a> (const byte *key, bool encmode=true)</td></tr>
<tr class="separator:a7dc960554f1e80092e62730769b9220b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d22aac97342f530e88c8e9cf75908c2"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a5d22aac97342f530e88c8e9cf75908c2">computeSBox</a> (byte id, byte line, byte col)</td></tr>
<tr class="separator:a5d22aac97342f530e88c8e9cf75908c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4ae4be5ed99cf4278c10742cd09d02"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a1c4ae4be5ed99cf4278c10742cd09d02">decrypt</a> (const byte *cipher_text, int cipher_len, const byte *key, int key_len, byte *plain_text, int plain_len)</td></tr>
<tr class="separator:a1c4ae4be5ed99cf4278c10742cd09d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a76488e8087e92ba7f6b827c72db61"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a61a76488e8087e92ba7f6b827c72db61">encrypt</a> (const byte *plain_text, int plain_len, const byte *key, int key_len, byte *cipher_text, int cipher_len)</td></tr>
<tr class="separator:a61a76488e8087e92ba7f6b827c72db61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f3ae226e5a206ab35c66eef2cd6f75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a97f3ae226e5a206ab35c66eef2cd6f75">processBlock</a> (const byte *in_block, byte *out_block)</td></tr>
<tr class="separator:a97f3ae226e5a206ab35c66eef2cd6f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985eafe4c2a27d27289a651ebaedd198"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a985eafe4c2a27d27289a651ebaedd198">feistel</a> (const byte *l_in, const byte *r_in, const byte *key, byte *l_out, byte *r_out, int rnd=0)</td></tr>
<tr class="separator:a985eafe4c2a27d27289a651ebaedd198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1448e493c89acc9d3dd68d1d522dd56b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a1448e493c89acc9d3dd68d1d522dd56b">functionF</a> (const byte *r_in, const byte *key, byte *r_out, int rnd=0)</td></tr>
<tr class="separator:a1448e493c89acc9d3dd68d1d522dd56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25226668c299388dfac613b5dc6c3bac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a25226668c299388dfac613b5dc6c3bac">getBit</a> (const byte *array, int array_len, int pos) const</td></tr>
<tr class="separator:a25226668c299388dfac613b5dc6c3bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e85a3c0fc857b378a1d3a6043ad2bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a55e85a3c0fc857b378a1d3a6043ad2bb">permutate</a> (const byte *p, int p_len, const byte *in_array, int in_len, byte *out_array, int out_len) const</td></tr>
<tr class="separator:a55e85a3c0fc857b378a1d3a6043ad2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545d394151b622c2920f634ef2e0b9e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a545d394151b622c2920f634ef2e0b9e2">printBitField</a> (const byte *bytefield, int len, int <a class="el" href="classBlockCipher.html#ab29ee03262fd620cd0659e860972faf0">block_len</a>=8) const</td></tr>
<tr class="separator:a545d394151b622c2920f634ef2e0b9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4fd9b18be0689fc3c9de0484dfd66c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#aaf4fd9b18be0689fc3c9de0484dfd66c">setBit</a> (byte *array, int array_len, int pos, bool value) const</td></tr>
<tr class="separator:aaf4fd9b18be0689fc3c9de0484dfd66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace050247cc1d89cf66f85ab890e29a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#ace050247cc1d89cf66f85ab890e29a73">getKeySchedule</a> (byte *keySchedule)</td></tr>
<tr class="separator:ace050247cc1d89cf66f85ab890e29a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classBlockCipher"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classBlockCipher')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classBlockCipher.html">BlockCipher</a></td></tr>
<tr class="memitem:a3c95996f1004e8bbf2b681168d1bd0a9 inherit pub_methods_classBlockCipher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockCipher.html#a3c95996f1004e8bbf2b681168d1bd0a9">BlockCipher</a> (unsigned int in_block_len=8)</td></tr>
<tr class="separator:a3c95996f1004e8bbf2b681168d1bd0a9 inherit pub_methods_classBlockCipher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55a65434bf1d4b59375916a0e58664c inherit pub_methods_classBlockCipher"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockCipher.html#ae55a65434bf1d4b59375916a0e58664c">hexToByte</a> (byte xdigit)</td></tr>
<tr class="separator:ae55a65434bf1d4b59375916a0e58664c inherit pub_methods_classBlockCipher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b64f6a987e85cfb75f0cc7ee035017e inherit pub_methods_classBlockCipher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockCipher.html#a0b64f6a987e85cfb75f0cc7ee035017e">readStream</a> (istream &amp;strm, byte *&amp;in_text, bool hex_mode, unsigned char blender='\0')</td></tr>
<tr class="separator:a0b64f6a987e85cfb75f0cc7ee035017e inherit pub_methods_classBlockCipher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44860cf631022230dfbea6f654dc1a2 inherit pub_methods_classBlockCipher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockCipher.html#ad44860cf631022230dfbea6f654dc1a2">writeStream</a> (ostream &amp;strm, byte *out_text, int out_len, bool hex_mode, int columns=30)</td></tr>
<tr class="separator:ad44860cf631022230dfbea6f654dc1a2 inherit pub_methods_classBlockCipher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a15e4c952af35d6b2d19655422b63a54e"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a15e4c952af35d6b2d19655422b63a54e">key_schedule</a> [16][6]</td></tr>
<tr class="separator:a15e4c952af35d6b2d19655422b63a54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aa9e5743835ee06b59c6fad7cf954fde2"><td class="memItemLeft" align="right" valign="top">static byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#aa9e5743835ee06b59c6fad7cf954fde2">ip</a> [64]</td></tr>
<tr class="separator:aa9e5743835ee06b59c6fad7cf954fde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed481831857615035c294e6a4fcee32"><td class="memItemLeft" align="right" valign="top">static byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a4ed481831857615035c294e6a4fcee32">fp</a> [64]</td></tr>
<tr class="separator:a4ed481831857615035c294e6a4fcee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726a2b9846d18e19770eea6d046b3d42"><td class="memItemLeft" align="right" valign="top">static byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a726a2b9846d18e19770eea6d046b3d42">ev</a> [48]</td></tr>
<tr class="separator:a726a2b9846d18e19770eea6d046b3d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde876e8b143237759022dd47f867945"><td class="memItemLeft" align="right" valign="top">static byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#acde876e8b143237759022dd47f867945">pc1</a> []</td></tr>
<tr class="separator:acde876e8b143237759022dd47f867945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cb4a171e849e673cfaf3d864614e81"><td class="memItemLeft" align="right" valign="top">static byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a16cb4a171e849e673cfaf3d864614e81">pc2</a> []</td></tr>
<tr class="separator:a16cb4a171e849e673cfaf3d864614e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65a5877e08227f4f1817cc6c49dd9bb"><td class="memItemLeft" align="right" valign="top">static byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#af65a5877e08227f4f1817cc6c49dd9bb">sbox</a> [8][64]</td></tr>
<tr class="separator:af65a5877e08227f4f1817cc6c49dd9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44d8fee3816aeefffd2049697a177cc"><td class="memItemLeft" align="right" valign="top">static byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#af44d8fee3816aeefffd2049697a177cc">pp</a> [32]</td></tr>
<tr class="separator:af44d8fee3816aeefffd2049697a177cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b1d159bad4462f7d89902cd65a8885"><td class="memItemLeft" align="right" valign="top">static byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDESCipher.html#a28b1d159bad4462f7d89902cd65a8885">total_rot</a> [16]</td></tr>
<tr class="separator:a28b1d159bad4462f7d89902cd65a8885"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classBlockCipher"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classBlockCipher')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classBlockCipher.html">BlockCipher</a></td></tr>
<tr class="memitem:ab29ee03262fd620cd0659e860972faf0 inherit pro_attribs_classBlockCipher"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockCipher.html#ab29ee03262fd620cd0659e860972faf0">block_len</a></td></tr>
<tr class="separator:ab29ee03262fd620cd0659e860972faf0 inherit pro_attribs_classBlockCipher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a296b6450dbdf2c35c70c74c628d9176b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296b6450dbdf2c35c70c74c628d9176b">&#9670;&nbsp;</a></span>DESCipher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DESCipher::DESCipher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leerer Konstruktor für die <a class="el" href="classDESCipher.html">DESCipher</a> Klasse </p>

</div>
</div>
<a id="ab2a6522ce5c469bfb055e1005ca03fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a6522ce5c469bfb055e1005ca03fbf">&#9670;&nbsp;</a></span>~DESCipher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DESCipher::~DESCipher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leerer Destruktor für die <a class="el" href="classDESCipher.html">DESCipher</a> Klasse </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7dc960554f1e80092e62730769b9220b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc960554f1e80092e62730769b9220b">&#9670;&nbsp;</a></span>computeKeySchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DESCipher::computeKeySchedule </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>encmode</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Berechnet die Rundenschlüssel und speichert diese in key_schedule ab. Es werden 16 Rundenschlüsselt berechnet, wobei jeder Rundenschlüssel 48 Bit groß ist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>ein konstanter byte Zeiger. Dabei handelt es sich um den 64 Bit großen Schlüssel.</td></tr>
    <tr><td class="paramname">encmode</td><td>gibt an, ob die Rundenschlüssel für das Verschlüsseln (encmode=true) oder das Entschlüsseln (encmode=false) erstellt werden sollen. encmode ist standardmäßig auf true gesetzt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d22aac97342f530e88c8e9cf75908c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d22aac97342f530e88c8e9cf75908c2">&#9670;&nbsp;</a></span>computeSBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte DESCipher::computeSBox </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>computeSBox liefert ein Arrayelement zurück. Bei dem Array handelt es sich um das sbox 2D Array. Das Element wird über id, line und col bestimmt.</p>
<p>DES verwendet 8 S-Boxen für Permutationen. Jede S-Box ist eine nicht lineare Abbildung von {0,1}⁶ nach {0,1}⁴. Das bedeutet, dass die S-Box einen 6 Bit Wert auf einen 4 Bit Wert abbildet/zuweist. Der param id gibt an, welche der 8 S-Boxen verwendet werden soll.</p>
<p>Es gibt 64 verschiedene Werte für {0,1}⁶. Jede S-Box ist deshalb ein 64 Elemente großes Array. Jedes Element ist ein Byte. Da auf {0,1}⁴ abgebildet wird, werden nur die unteren 4 Bits des Bytes gesetzt. Die S-Box kann auch als 4x16 Matrix dargestellt werden. Die ersten 16 Elemente des 64 Elementearrays bilden die erste Zeile der 4x16 Matrix, die darauffolgenden 16 Elemente an Index 16 bis Index 31 des 64 Elementearrays bilden die zweite Zeile der 4x16 Matrix und so weiter. Die param line, die Zeile, und param col, die Spalte, bestimmen das Element Matrix bzw. des 64 Elementearrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>gibt an, welche SBox bzw. welches Array für die Berechnung verwendet werden soll. Es gibt 8 verschiedene SBoxen/Arrays in sbox. Valide Werte von id sind also 0,1,...,7.</td></tr>
    <tr><td class="paramname">line</td><td>gibt die Zeile der 4x16 S-Box Matrix an. Da es sich intern um Arrays handelt fängt man hier ab Index 0 an. Valide Werte sind deshalb 0,1,2 und 3.</td></tr>
    <tr><td class="paramname">col</td><td>gibt die Spalte der 4x16 S-Box Matrix an. Da es sich intern um Arrays handelt fängt man hier ab Index 0 an. Valide Werte sind deshalb 0,1,2,...,15.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Der Wert eines Elements der S-Boxen. Der Rückgabewert ist vom Typ byte, allerdings werden nur die unteren 4 Bits gesetzt sein. </dd></dl>

</div>
</div>
<a id="a1c4ae4be5ed99cf4278c10742cd09d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4ae4be5ed99cf4278c10742cd09d02">&#9670;&nbsp;</a></span>decrypt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DESCipher::decrypt </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>cipher_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cipher_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>plain_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>plain_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>decrypt entschlüsselt cipher_len Bytes ab cipher_text mit dem key_len großen Schlüssel key und speichert den entschlüsselten Text im plain_len großen plain_text Speicherblock ab.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipher_text</td><td>zeigt auf einen Speicherblock, in dem der mindestens cipher_len Byte große verschlüsselte zu entschlüsselnde Text gespeichert ist.</td></tr>
    <tr><td class="paramname">cipher_len</td><td>gibt die Größe des cipher_text in Byte an. cipher_len muss ein vielfaches von der durch <a class="el" href="classBlockCipher.html">BlockCipher</a> spezifizierten block_len sein.</td></tr>
    <tr><td class="paramname">key</td><td>zeigt auf einen Speicherblock, in dem der 8 Byte große Key gespeichert ist. Dieser Key wird für das entschlüsseln verwendet. Speziell werden aus diesem Key die 16 Rundenschlüssel berechnet.</td></tr>
    <tr><td class="paramname">key_len</td><td>gibt die Größe des key in Byte an. key_len muss gleich 8 sein.</td></tr>
    <tr><td class="paramname">plain_text</td><td>zeigt auf einen mindestens plain_len großen Speicherblock, in dem der entschlüsselte cipher_text gespeichert wird.</td></tr>
    <tr><td class="paramname">plain_len</td><td>gibt die Größe des plain_text in Byte an. Um das komplette Ergebnis zu speichern muss plain_len größer als cipher_len sein.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>den Wert in (param) plain_len </dd></dl>

<p>Implements <a class="el" href="classBlockCipher.html#a8a401652231a372a0ec248ff0fb5487a">BlockCipher</a>.</p>

</div>
</div>
<a id="a61a76488e8087e92ba7f6b827c72db61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a76488e8087e92ba7f6b827c72db61">&#9670;&nbsp;</a></span>encrypt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DESCipher::encrypt </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>plain_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>plain_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>cipher_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cipher_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>encrypt verschlüsselt plain_len Bytes ab plain_text mit dem key_len großen Schlüssel key und speichert den verschlüsselten Text im cipher_len großen cipher_text Speicherblock ab.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plain_text</td><td>zeigt auf einen Speicherblock, in dem der mindestens plain_len Byte große zu verschlüsselnde Text gespeichert ist.</td></tr>
    <tr><td class="paramname">plain_len</td><td>gibt die Größe des plain_text in Byte an. plain_len muss ein vielfaches von der durch <a class="el" href="classBlockCipher.html">BlockCipher</a> spezifizierten block_len sein.</td></tr>
    <tr><td class="paramname">key</td><td>zeigt auf einen Speicherblock, in dem der 8 Byte große Key gespeichert ist. Dieser Key wird für das verschlüsseln verwendet. Mit diesem key kann der resultierende cipher_text auch wieder entschlüsselt werden. Speziell werden aus diesem Key die 16 Rundenschlüssel berechnet.</td></tr>
    <tr><td class="paramname">key_len</td><td>gibt die Größe des key in Byte an. key_len muss gleich 8 sein.</td></tr>
    <tr><td class="paramname">cipher_text</td><td>zeigt auf einen mindestens cipher_len großen Speicherblock, in dem der verschlüsselte plain_text gespeichert wird.</td></tr>
    <tr><td class="paramname">cipher_len</td><td>gibt die Größe des cipher_text in Byte an. Um das komplette Ergebnis zu speichern muss cipher_len größer als plain_len sein.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>den Wert in (param) plain_len </dd></dl>

<p>Implements <a class="el" href="classBlockCipher.html#a702dd06a7078ef55c4e9a6482893b07d">BlockCipher</a>.</p>

</div>
</div>
<a id="a985eafe4c2a27d27289a651ebaedd198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985eafe4c2a27d27289a651ebaedd198">&#9670;&nbsp;</a></span>feistel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DESCipher::feistel </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>l_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>r_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>l_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>r_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rnd</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation der Feistel-Chiffre. Dabei wird l_out auf r_in gesetzt. Weiter wird die f Funktion mit r_in und key aufgerufen und die Ausgabe der Funktion wird mit l_in XOR'd und in r_out geschrieben.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l_in</td><td>zeigt auf den 32 Bit großen linken Teil.</td></tr>
    <tr><td class="paramname">r_in</td><td>zeigt auf den 32 Bit großen rechten Teil.</td></tr>
    <tr><td class="paramname">key</td><td>zeigt auf einen 48 Bit großen Rundenschlüssel.</td></tr>
    <tr><td class="paramname">l_out</td><td>In l_out wird der berechnete linke Teil geschrieben.</td></tr>
    <tr><td class="paramname">r_out</td><td>In r_out wird der berechnete rechte Teil geschrieben. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1448e493c89acc9d3dd68d1d522dd56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1448e493c89acc9d3dd68d1d522dd56b">&#9670;&nbsp;</a></span>functionF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DESCipher::functionF </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>r_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>r_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rnd</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation der DES-Funktion f. Sie ist eine beliebige injektive Abbildung von {0, 1}^(32) × {0, 1}^(48) nach {0, 1}^(32). Dabei sind r_in und key die Eingaben und r_out die Ausgabe der Funktion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r_in</td><td>zeigt auf einen 32 Bit großen Speicherblock. Diese 32 Bit werden mit dem Rundenschlüssel key verarbeitet.</td></tr>
    <tr><td class="paramname">key</td><td>zeigt auf einen 48 Bit großen Rundenschlüssel.</td></tr>
    <tr><td class="paramname">r_out</td><td>In r_out wird die 32 Bit Ausgabe der f Funktion geschrieben.</td></tr>
    <tr><td class="paramname">rnd</td><td>ist optional, gibt die aktuelle DES Runde an und wird in der aktuellen Implementation nicht verwendet. Sie kann in der Zukunft für Debug Ausgaben verwendet werden. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25226668c299388dfac613b5dc6c3bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25226668c299388dfac613b5dc6c3bac">&#9670;&nbsp;</a></span>getBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DESCipher::getBit </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>array_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Liefert das pos-te Bit des array zurück.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>verweist auf einen Speicherblock.</td></tr>
    <tr><td class="paramname">array_len</td><td>gibt die Größe des array in Byte an.</td></tr>
    <tr><td class="paramname">pos</td><td>gibt an, dass das pos-te Bit zurückgegeben werden soll.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>den Wert des pos-ten Bits des array. </dd></dl>

</div>
</div>
<a id="ace050247cc1d89cf66f85ab890e29a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace050247cc1d89cf66f85ab890e29a73">&#9670;&nbsp;</a></span>getKeySchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DESCipher::getKeySchedule </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>keySchedule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>getKeySchedule speichert die 16 6-Byte großen Rundenschlüssel hintereinander in der durch keySchedule gezeigten Position ab. Ab keySchedule muss darum 16*6=96 Byte Speicher reserviert sein.</p>
<p>Zeigt auf einen mindestens 96 Byte großen Speicherblock. In diesen Speicherblock werden die Rundenschlüssel geschrieben. </p>

</div>
</div>
<a id="a55e85a3c0fc857b378a1d3a6043ad2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e85a3c0fc857b378a1d3a6043ad2bb">&#9670;&nbsp;</a></span>permutate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DESCipher::permutate </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>in_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>out_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>p ist ein p_len großes Array mit Integern. Die Bits in in_array werden an die durch den Wert der Elemente in p bestimmen Position ins out_array geschrieben. Das bedeutet, dass das i-te Bit in in_array an das (p[i]-1)-te Bit in out_array geschrieben, wobei i = 0,1,...,p_len-1. Die Indices in p starten bei 1 und nicht bei 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>zeigt auf ein p_len byte großes Array, wobei jedes Element des Arrays eine Zuordnung eines Bits auf in_array zu out_array bestimmt.</td></tr>
    <tr><td class="paramname">p_len</td><td>gibt die Größe in byte des p Arrays an.</td></tr>
    <tr><td class="paramname">in_array</td><td>zeigt auf ein in_len byte großes Array. Bits aus in_array werden später an durch p beschriebene Positionen in das out_array geschrieben. Es gilt zu beachten, dass möglicherweise keine, manche oder alle Bits aus in_array an Positionen in out_array kopiert werden und dass auch manche Bits mehrmals in out_array kopiert werden können.</td></tr>
    <tr><td class="paramname">in_len</td><td>gibt die Größe in bytes des in_array an.</td></tr>
    <tr><td class="paramname">out_array</td><td>zeigt auf ein out_len byte großes Array. Die out_len*8 Bits ab out_array werden auf den Wert von Bits des in_array gesetzt.</td></tr>
    <tr><td class="paramname">out_len</td><td>gibt die Größe in bytes des out_array an. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a545d394151b622c2920f634ef2e0b9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545d394151b622c2920f634ef2e0b9e2">&#9670;&nbsp;</a></span>printBitField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DESCipher::printBitField </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>bytefield</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_len</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>printBitField gibt 8*len Bit ab bytefield als Bitfolge auf der Standardausgabe aus. Nach jeweils block_len bits wird ein Leerzeichen ausgegeben, außer auf das Leerzeichen folgt kein weiteres Bit (no trailing whitespace).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytefield</td><td>zeigt auf eine Position im Speicher, ab der len Bytes auf der Standardausgabe ausgegeben werden.</td></tr>
    <tr><td class="paramname">len</td><td>gibt die Anzahl der Byte an</td></tr>
    <tr><td class="paramname">block_len</td><td>gibt an, nach jeweils wievielen ausgegebenen Bits ein Leerzeichen ausgegeben werden soll. block_len ist standardmäßig auf 8 gesetzt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97f3ae226e5a206ab35c66eef2cd6f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f3ae226e5a206ab35c66eef2cd6f75">&#9670;&nbsp;</a></span>processBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DESCipher::processBlock </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>in_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>out_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Chiffriert block_len bytes ab in_block unter Verwendung der Rundenschlüssel in der Schlüsseltabelle key_schedule mittels DES Das Ergebnis wird in den block_len bytes ab out_block gespeichert. Als Betriebsmodus wird der ECB-Modus verwendet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_block</td><td>zeigt auf die block_len Bytes, welche chiffriert werden sollen</td></tr>
    <tr><td class="paramname">out_block</td><td>zeigt auf einen Speicherbereich, der mindestens out_block Bytes groß sein muss und in welchen das chiffrierte Ergebnis geschrieben wird. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf4fd9b18be0689fc3c9de0484dfd66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4fd9b18be0689fc3c9de0484dfd66c">&#9670;&nbsp;</a></span>setBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DESCipher::setBit </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>array_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>setBit setzt das pos-te Bit in array auf den Wert von value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>zeigt auf ein array_len Byte großes Feld.</td></tr>
    <tr><td class="paramname">array_len</td><td>gibt die Größe des array in Bytes an. Damit das Bit gesetzt werden kann, muss pos &lt; 8*array_len sein.</td></tr>
    <tr><td class="paramname">pos</td><td>gibt an, dass das pos-te Bit ab array gesetzt werden soll.</td></tr>
    <tr><td class="paramname">value</td><td>Das pos-te Bit wird auf value gesetzt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a726a2b9846d18e19770eea6d046b3d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726a2b9846d18e19770eea6d046b3d42">&#9670;&nbsp;</a></span>ev</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte DESCipher::ev</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">        32, 1, 2, 3, 4, 5,</div><div class="line">        4, 5, 6, 7, 8, 9,</div><div class="line">        8, 9, 10, 11, 12, 13,</div><div class="line">        12, 13, 14, 15, 16, 17,</div><div class="line">        16, 17, 18, 19, 20, 21,</div><div class="line">        20, 21, 22, 23, 24, 25,</div><div class="line">        24, 25, 26, 27, 28, 29,</div><div class="line">        28, 29, 30, 31, 32, 1</div><div class="line">}</div></div><!-- fragment --><p>ev wird am Anfang der functionF Funktion für die Expansion und Permutation des r_in verwendet. </p>

</div>
</div>
<a id="a4ed481831857615035c294e6a4fcee32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed481831857615035c294e6a4fcee32">&#9670;&nbsp;</a></span>fp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte DESCipher::fp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">        40, 8, 48, 16, 56, 24, 64, 32,</div><div class="line">        39, 7, 47, 15, 55, 23, 63, 31,</div><div class="line">        38, 6, 46, 14, 54, 22, 62, 30,</div><div class="line">        37, 5, 45, 13, 53, 21, 61, 29,</div><div class="line">        36, 4, 44, 12, 52, 20, 60, 28,</div><div class="line">        35, 3, 43, 11, 51, 19, 59, 27,</div><div class="line">        34, 2, 42, 10, 50, 18, 58, 26,</div><div class="line">        33, 1, 41, 9, 49, 17, 57, 25</div><div class="line">}</div></div><!-- fragment --><p>fp wird am Ende der processBlock Funktion für die Permutation des Ergebnis der Rundendurchläufe verwendet. </p>

</div>
</div>
<a id="aa9e5743835ee06b59c6fad7cf954fde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e5743835ee06b59c6fad7cf954fde2">&#9670;&nbsp;</a></span>ip</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte DESCipher::ip</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">        58, 50, 42, 34, 26, 18, 10, 2,</div><div class="line">        60, 52, 44, 36, 28, 20, 12, 4,</div><div class="line">        62, 54, 46, 38, 30, 22, 14, 6,</div><div class="line">        64, 56, 48, 40, 32, 24, 16, 8,</div><div class="line">        57, 49, 41, 33, 25, 17, 9, 1,</div><div class="line">        59, 51, 43, 35, 27, 19, 11, 3,</div><div class="line">        61, 53, 45, 37, 29, 21, 13, 5,</div><div class="line">        63, 55, 47, 39, 31, 23, 15, 7</div><div class="line">}</div></div><!-- fragment --><p>ip wird am Anfang der processBlock Funktion für die Permutation des in_block verwendet. </p>

</div>
</div>
<a id="a15e4c952af35d6b2d19655422b63a54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e4c952af35d6b2d19655422b63a54e">&#9670;&nbsp;</a></span>key_schedule</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte DESCipher::key_schedule[16][6]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In key_schedule werden die 16 6-Byte großen Rundenschlüssel gespeichert. Die Felder werden von der computeKeySchedule gesetzt. Jeder Rundenschlüssel wird der Reihe nach über die feistel Funktion an die f Funktion gegeben, um dort zusammen mit dem r_in Zustand verarbeitet zu werden.</p>
<p>Das 2D Array kann mit der getKeySchedule Funktion ausgegeben werden. </p>

</div>
</div>
<a id="acde876e8b143237759022dd47f867945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde876e8b143237759022dd47f867945">&#9670;&nbsp;</a></span>pc1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte DESCipher::pc1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">        57, 49, 41, 33, 25, 17, 9,</div><div class="line">        1, 58, 50, 42, 34, 26, 18,</div><div class="line">        10, 2, 59, 51, 43, 35, 27,</div><div class="line">        19, 11, 3, 60, 52, 44, 36,</div><div class="line"></div><div class="line">        63, 55, 47, 39, 31, 23, 15,</div><div class="line">        7, 62, 54, 46, 38, 30, 22,</div><div class="line">        14, 6, 61, 53, 45, 37, 29,</div><div class="line">        21, 13, 5, 28, 20, 12, 4</div><div class="line">}</div></div><!-- fragment --><p>pc1 wird in der computeKeySchedule Funktion verwendet, um für jedes Bit von jedem Rundenschlüssel zu berechnen, welches Bit des Rundenschlüssels auf welches Bit des key gesetzt werden soll. </p>

</div>
</div>
<a id="a16cb4a171e849e673cfaf3d864614e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cb4a171e849e673cfaf3d864614e81">&#9670;&nbsp;</a></span>pc2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte DESCipher::pc2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">        14, 17, 11, 24, 1, 5,</div><div class="line">        3, 28, 15, 6, 21, 10,</div><div class="line">        23, 19, 12, 4, 26, 8,</div><div class="line">        16, 7, 27, 20, 13, 2,</div><div class="line">        41, 52, 31, 37, 47, 55,</div><div class="line">        30, 40, 51, 45, 33, 48,</div><div class="line">        44, 49, 39, 56, 34, 53,</div><div class="line">        46, 42, 50, 36, 29, 32</div><div class="line">}</div></div><!-- fragment --><p>pc2 wird wie pc1 in der computeKeySchedule Funktion verwendet, um für jedes Bit von jedem Rundenschlüssel zu berechnen, welches Bit des Rundenschlüssels auf welches Bit des key gesetzt werden soll. </p>

</div>
</div>
<a id="af44d8fee3816aeefffd2049697a177cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44d8fee3816aeefffd2049697a177cc">&#9670;&nbsp;</a></span>pp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte DESCipher::pp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">        16, 7, 20, 21,</div><div class="line">        29, 12, 28, 17,</div><div class="line">        1, 15, 23, 26,</div><div class="line">        5, 18, 31, 10,</div><div class="line">        2, 8, 24, 14,</div><div class="line">        32, 27, 3, 9,</div><div class="line">        19, 13, 30, 6,</div><div class="line">        22, 11, 4, 25</div><div class="line">}</div></div><!-- fragment --><p>pp wird abschließend in der f Funktion für eine Permutation mit dem Ergebnis der S-Boxen verwendet. Das Ergebnis dieser Permutation wird dann über r_out zurückgeliefert. </p>

</div>
</div>
<a id="af65a5877e08227f4f1817cc6c49dd9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65a5877e08227f4f1817cc6c49dd9bb">&#9670;&nbsp;</a></span>sbox</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte DESCipher::sbox</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bei sbox handelt es sich um 8 64-Bit Felder bzw. 8 4x16 Matrizen. Das sind die S-Boxen, welche über die computeSBox Funktion für die Permutationen in der f Funktion (functionF) verwendet werden. </p>

</div>
</div>
<a id="a28b1d159bad4462f7d89902cd65a8885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b1d159bad4462f7d89902cd65a8885">&#9670;&nbsp;</a></span>total_rot</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte DESCipher::total_rot</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">        1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28</div><div class="line">}</div></div><!-- fragment --><p>total_rot gibt die Anzahl der zyklischen Linksverschiebungen für jeden Rundenschlüssel an. Das wird in der computeKeySchedule Funktion verwendet. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/sinflair/P/crypto/AK/src/Praktikum-DES/<a class="el" href="DESCipher_8h_source.html">DESCipher.h</a></li>
<li>/home/sinflair/P/crypto/AK/src/Praktikum-DES/DESCipher.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
